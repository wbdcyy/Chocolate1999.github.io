<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020 零基础到快速开发  Vue全家桶开发电商管理系统（Element-UI）【目录】</title>
      <link href="/posts/34924/"/>
      <url>/posts/34924/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>又是一个寒假，曾经一个学霸说过：<code>寒假是用来反超的！</code>，所以这个寒假来和我一起学习Vue把，我会把我做的全部整合在这一个目录当中，算是给自己一个学习记录，也方便读者进行查阅。我的项目其实在1月24日正好过除夕的那天完成了，大约是10天左右的时间，边记录边做项目，后面发现我这个专栏访问量达到了5w，还是有一点人气的，休息三天后，今晚打算来一个总结吧，见证一个从一个不认识Vue是什么的小白到如何快速开发的成长吧~</p><p><font color=red>项目源码我放在码云上保管了,具体地址如下，可进行二次开发:</font><br><a href="https://gitee.com/Chocolate666/vue_shop/tree/master" target="_blank" rel="noopener">https://gitee.com/Chocolate666/vue_shop/tree/master</a></p><h2 id="电商后台管理系统的技术选型"><a href="#电商后台管理系统的技术选型" class="headerlink" title="电商后台管理系统的技术选型"></a>电商后台管理系统的技术选型</h2><p>① 前端项目技术栈：</p><ul><li>Vue</li><li>Vue-router</li><li>Element-UI</li><li>Axios</li><li>Echarts</li></ul><p>② 后端项目</p><ul><li>Node.js</li><li>Express</li><li>Jwt</li><li>Mysql</li><li>Sequelize</li></ul><h2 id="快速入门篇"><a href="#快速入门篇" class="headerlink" title="快速入门篇"></a>快速入门篇</h2><blockquote><p>本篇主要是给刚入门Vue的来学习的，里面有一些简单实例，比如记事本，所处城市天气查询，音乐播放配mv等，同时还解决了学习时遇到的问题，学会下面的内容可以算是入门了</p></blockquote><ol><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103952917" target="_blank" rel="noopener">2020 零基础 Vue快速入门 Vue基础篇 【详细】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103957276" target="_blank" rel="noopener">2020 零基础 Vue快速入门 Vue指令 本地应用篇【整理】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103964103" target="_blank" rel="noopener">2020 零基础 Vue快速入门 教开发一个记事本（激发编程乐趣）【整理+源码】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103969483" target="_blank" rel="noopener">2020 零基础 Vue快速入门 Vue2.0使用ES6语法的箭头函数=&gt; 对this作用域的理解 【整理】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103969923" target="_blank" rel="noopener">2020 零基础 Vue快速入门 Vue项目中引入外部css以及js文件的方法 【整理】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103967761" target="_blank" rel="noopener">2020 零基础 Vue快速入门 网络应用 axios+Vue【整理】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103972240" target="_blank" rel="noopener">2020 零基础 Vue快速入门 教开发天气查询网页—天知道（激发编程乐趣）【整理+源码】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103974082" target="_blank" rel="noopener">2020 零基础 Vue综合应用 教开发音乐播放器—悦听（激发编程乐趣）【整理+源码】</a></li></ol><h2 id="电商管理系统开发（百科全书）"><a href="#电商管理系统开发（百科全书）" class="headerlink" title="电商管理系统开发（百科全书）"></a>电商管理系统开发（百科全书）</h2><ol><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103983409" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）项目概述篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103983723" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）项目初始化篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103990497" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）使用码云托管项目篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103995613" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）配置MySQL</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/103996682" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）登录退出功能实现</a></li><li><a  href="https://blog.csdn.net/weixin_42429718/article/details/104012018" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）主页布局开发</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104018448" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）用户列表开发</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104023786" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【添加用户】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104024379" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【修改用户】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104031033" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【删除用户】</a> </li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104031835" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【权限列表】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104033075" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【角色列表】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104044038" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【分配权限】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104044630" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）【分配角色】</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104045709" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）商品分类篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104056728" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）分类参数篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104063899" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）商品列表篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104077321" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）订单管理篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104078211" target="_blank" rel="noopener">2020 零基础到快速开发 Vue全家桶开发电商管理系统（Element-UI）数据统计篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104079409" target="_blank" rel="noopener">2020 Vue零基础 基于Element-UI开发 （全）项目优化与部署上线（npm，基于vue ui） 上篇</a></li><li><a href="https://blog.csdn.net/weixin_42429718/article/details/104079909" target="_blank" rel="noopener">2020 Vue零基础 基于Element-UI开发 （全）项目优化与部署上线（npm，基于vue ui） 下篇</a></li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><hr><p><strong><font color=DeepPink>最后，看完本篇博客后，觉得挺有帮助的话，可以继续查看专栏其它内容嗷，一起来学习Vue吧~</font></strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020011511203890.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h4 id="点击进入Vue❤学习专栏"><a href="#点击进入Vue❤学习专栏" class="headerlink" title=" 点击进入Vue❤学习专栏~"></a><a href="https://blog.csdn.net/weixin_42429718/category_9656024.html" target="_blank" rel="noopener"> 点击进入Vue❤学习专栏~</a></h4>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> Element-UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我的大学ACM江湖</title>
      <link href="/posts/24659/"/>
      <url>/posts/24659/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大二下学期正式入ACM，大家一看这时间就知道算是挺晚的了，因为我大一比较迷茫，没有在大学加过任何部门，学习也提不上什么劲，大二上开始有了自己的想法，在班上成功竞选上了学习委员，然后我越发积极，在大二上的寒假假期独自在家刷题，目的就是为了蓝桥杯，初赛挺适合新手锻炼的，刷题目的就是为了学校的选拔赛，争取名额，后面当然得到了名额，最后在比赛也取得了省二的成绩，这让我无比激动，原来付出真的有回报，从此我的ACM生涯就开始了！</p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/100115006" target="_blank" rel="noopener">推荐阅读这篇文章——2019年（第15届）湖南省大学生计算机程序设计竞赛之【赛前动员暨暑假集训总结】</a></p><h2 id="心得与体会"><a href="#心得与体会" class="headerlink" title="心得与体会"></a>心得与体会</h2><p>==2020年2月27日更新==</p><p>我把原来的分享模板标题给改了，改成了“关于我的大学ACM江湖”，想着我的这篇文章应该是以分享心得与体会为主，而不是为了因模板来骗访问量的，疫情目前算是有待控制了，开学应该不远了，2月24日决定了还是退役了，大三下要准备实习方面的事情了，感叹大学时间过得很快，不过也过得挺充实的，我的实习方向是前端开发工程师，acm之路结束了，后续的大多数文章会与前端方面有关的，主要还是Vuejs。</p><p>最近呢，也还在准备深信服前端面试工作，今天整理了一部分面试题。</p><p>放心，当我整理完毕后会分享出来的，会放在下面这个专栏里，不妨关注一下这个专栏，里面也还是有一些个人觉得还不错的文章！</p><p><a href="https://blog.csdn.net/weixin_42429718/category_9656024.html" target="_blank" rel="noopener">Vue专栏❤</a></p><p>说在最后，<strong><font color=red>愿在努力的你能拿到offer</font></strong>！</p><hr/><p>有的时候，感觉自己刷题刷不动的时候，我就会看一看大神关于退役的总结，没想到今天自己也会来总结了，我就简单和大家聊一聊ACM把<br>走上ACM，就像一个表情包所说，本就是逆天而行，<strong><font color=red>很多人走着走着就放弃了，打不动了，学习到了瓶颈期，其实并不是ACM他们会放弃，做其他的也依旧会放弃。</font></strong> 我曾经问过打过ACM然后放弃的一位学长，因为当时我也在考虑自己是继续打下去还是放弃乖乖增加项目经验，他说<strong>打ACM对找工作其实没有很多帮助，因为对于普通学校来说，或者对于普通人来说，想要拿到那种区域赛的奖是有一定难度的，真正有帮助的还是去实践增加项目经验，后面补了一句当初有点后悔自己去打acm，花费了很多时间在这上面，把这些时间利用起来做项目的话可能现在更好。</strong> 后面又和学长聊了聊工作方面的事情，我原本有点消极的感受立马消散了，后感谢了学长和我交谈。</p><hr><p>请读者海纳百川有容乃大，或许这就是广大acm同胞放弃的观念把，这里，我先表明我自己的观点。<strong><font color=red>打ACM绝对不是一件让我后悔的事情，如果自己喜欢的事情都会做的后悔，那做其他事还有什么意义！</font></strong> 正是因为接触了ACM，我的学习状态一直保持了下去，养成了一个积极好学的习惯，尽管每一周都会因为一个题目弄的自闭，但是成长的过程本身就是这样，不吃点苦哪能感受甜的味道；正是因为接触了ACM，我才坚持去写CSDN博客，才有了现在这样的成就；正是因为接触了ACM，算综测的时候我不再是拿不出东西，我能拿出一点比赛的证书为自己加分；正是因为接触了ACM,我才会为了拿到学校奖学金而拼搏，而奋斗！</p><p>对于计算机专业来说，我想ACM是必经之路，走上ACM道路不代表你就一定能拿奖，也不代表你就一定要去比赛，我们去公司笔试很多都是与这方面有关，而且有些公司还会强调要有一定ACM基础，可看重要程度！<br>当然，能够拿奖是走上ACM道路的一个目标，也是一份荣誉！</p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/103052899" target="_blank" rel="noopener">推荐阅读这篇博客——第四届全国中医药院校大学生程序设计竞赛【河南-郑州之旅】暨FPX夺冠&amp;湖南中医药大学夺冠！（上篇）——记录美好的时光！</a></p><p>谈了ACM，也谈了大众观念，也谈了自己的态度，那段时光只有经历的人会有共同的感受，<strong><font color=red> 希望看到这篇文章的你有着“科比”精神，对于自己喜欢、热爱的事情坚持下去，如果连自己喜欢的事情都做不好，坚持不下去，还谈什么增加项目经验，人生不就是为了自己热爱喜欢的东西而拼搏么？跌倒了一次又一次爬起来，继续走下去… </font></strong></p><h2 id="分享模板"><a href="#分享模板" class="headerlink" title="分享模板"></a>分享模板</h2><p>下面就是我整理的ACM模板了，总共429页，但是大小也就1MB多点，想来想去，还是分享出去吧，自己退役了，想着模板还能继续发挥它的作用，也是件不错的事情，那么我就将我的“武器”授予给你们了，好好使用~<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020012710292183.png"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020012710273520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>链接：<a href="https://pan.baidu.com/s/15SonnPLAqKIr96ZwxRi1AQ" target="_blank" rel="noopener">https://pan.baidu.com/s/15SonnPLAqKIr96ZwxRi1AQ</a><br>提取码：klw3 </p><p><font color=chocolate>PS：如果你觉得本模板不错的话，欢迎打赏一下，原则上免费自取，但是也仅需1元打赏就好了，我想知道我的模版是否够好，如果不够好的话，我再更新一下~</p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200127113159877.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  width=55%><hr><p><font size=4>  ==2020年2月7日更新== ，想不到还真有打赏给我的啦，点赞数也挺多的，谢谢各位的支持！</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vue全家桶+SSR+Koa2全栈开发】项目搭建过程  整合  学习目录（持续更新中）</title>
      <link href="/posts/35725/"/>
      <url>/posts/35725/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><blockquote><div>大家好，这里是<font color=chocolate>lionLoveVue</font>，基础知识决定了编程思维，学如逆水行舟，不进则退。金三银四，为了面试也还在慢慢积累知识，Github上面可以直接查看所有前端知识点梳理，<a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes" target="_blank" rel="noopener">github传送门</a>，觉得不错，点个Star★，好运连连，Offer终究鼠于你，持续更新中。另外，也可以关注微信公众号：<font color=chocolate>小狮子前端Vue</font>，源码以及资料今后都会放在里面。</div></blockquote><h2 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h2><hr/><p>全局安装<code>vue/cli</code>脚手架</p><p>管理员身份运行cmd，执行如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure><p>命令行输入<code>vue ui</code> 打开可视化界面</p><p>使用默认<code>default</code>配置</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200405213511680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p>用vscode打开项目，执行如下命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm/cnpm run serve</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 查看是否配置成功</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">推荐阅读：官方文档-自定义指令</a></p><p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><strong>父子组件的通信方式</strong></p><p>父组件传子组件，是在子组件使用<code>props</code>，然后再父组件，通过<code>:=</code>绑定变量</p><p>子组件传父组件，是在子组件使用自定义事件，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件配置</span></span><br><span class="line">@click=<span class="string">"$emit('patch(xxx)')"</span></span><br><span class="line"><span class="comment">//父组件配置</span></span><br><span class="line">@patch=<span class="string">"func"</span></span><br></pre></td></tr></table></figure><p>如果是跨组件，不是父子组件关系，就使用 <code>Vuex</code>。</p><p><strong>slot</strong></p><p>插槽在组件抽象设计中的应用：</p><p>原本组件不能嵌入html内容，但通过父子组件传递插槽即可实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">slot=<span class="string">"a"</span></span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;slot name=<span class="string">"a"</span>&gt;&lt;<span class="regexp">/slot&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Vuex基础"><a href="#Vuex基础" class="headerlink" title="Vuex基础"></a>Vuex基础</h2><hr/><p>Vuex简单来说就是多个组件共享数据，但是组件是不能直接操纵数据的，如下图所示，我们的数据放在紫色部分<code>state</code>里面（没有放在<code>data</code>里），操作数据源由红色部分<code>Mutations</code>完成，什么时候操控数据有黄色部分<code>Actions</code>来控制，这里就是由用户来操纵组件来触发 <code>Actions</code> ，最后，由 <code>Actons</code> 提交 <code>Commit</code> 通知改变数据源，来完成组件视图的更新渲染。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200406210920118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p><strong>安装Vuex</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm/cnpm i vuex</span><br></pre></td></tr></table></figure><h2 id="Koa2基础"><a href="#Koa2基础" class="headerlink" title="Koa2基础"></a>Koa2基础</h2><hr/><h3 id="koa-generator"><a href="#koa-generator" class="headerlink" title="koa-generator"></a>koa-generator</h3><p>管理员身份打开cmd，运行如下代码，全局安装</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g koa-generator</span><br></pre></td></tr></table></figure><p>使用<code>git bash</code>，在文件夹内创建项目</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">koa2 -e project_name</span><br></pre></td></tr></table></figure><p>-e 表示使用<code>ejs</code>，不加和 <code>node</code> 一样</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407104615983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>接下来，执行安装命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd koa2_learn</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>安装&amp;更新 <code>fsevents</code> 包</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --update-binary</span><br></pre></td></tr></table></figure><p>run app命令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">DEBUG=koa2_learn:* npm start</span><br></pre></td></tr></table></figure><p>执行后输出 <code>node bin/www</code> 说明服务端已经跑起来了</p><p>访问 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 查看页面效果</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040710530544.png"  alt=""><br>我们查看 <code>package.json</code> ，发现启动脚本是通过 <code>npm scripts</code> ，如果你想要自启动的话，执行如下命令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407105417668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>对于上述执行指令，<code>dev</code> 和 <code>prd</code> 必须使用 <code>npm run xxx</code></p><p>与此同时，我们在 <code>index.js</code> 全局打印一下，加入如下代码：<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407105756505.png"  alt=""></p><p>在 <code>git bash</code> 中执行如下命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>说明我们改变服务端脚本，服务能够自启动了<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407105837914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h2 id="Koa2中间件"><a href="#Koa2中间件" class="headerlink" title="Koa2中间件"></a>Koa2中间件</h2><hr/><p>图片来自Koa2官方，大致意思就是服务端接受客户端的 <code>Request</code>，经过服务端一些流程，然后 <code>Response</code> 返回给浏览器，其中每一个环，都是一个中间件。进来的时候会经过某个中间件，出去的时候也会经过，<strong>这样的机制就可以让中间件引用顺序和代码执行顺序不一致。</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407112345912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h2 id="mongoose基础"><a href="#mongoose基础" class="headerlink" title="mongoose基础"></a>mongoose基础</h2><hr/><h3 id="mongodb概念-amp-安装"><a href="#mongodb概念-amp-安装" class="headerlink" title="mongodb概念&amp;安装"></a>mongodb概念&amp;安装</h3><p>mongodb属于<code>非关系型</code>数据库，与<code>mysql</code>相对的（mysql是关系型数据库）</p><p>mongodb里面没有 <code>table</code>表，只有 <code>Collections</code></p><p>原本mysql一行叫做 <code>row</code>，而在mongodb中叫做 <code>document</code>，原本一列叫做 <code>cloumn</code>，而现在叫做 <code>fields</code></p><p>windows 10 安装教程：</p><p><a href="https://www.runoob.com/mongodb/mongodb-window-install.html" target="_blank" rel="noopener">推荐阅读：Windows 平台安装 MongoDB</a></p><p><strong>注意</strong></p><p>安装<code>Install MongoDB Compass</code> 不勾选，否则可能要很长时间都一直在执行安装，MongoDB Compass是一个图形界面管理工具，后面会去下载一个图形界面管理工具<code>Robo3T</code>。</p><p>其它选项就默认选择 <code>next</code> 即可</p><p>找到下面位置下的两个 <code>.exe</code> 都点击运行一下好了…  （启动服务应该是下面那一个）<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407135608794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p><strong>检测是否安装成功</strong></p><p>访问：<a href="http://127.0.0.1:27017/" target="_blank" rel="noopener">http://127.0.0.1:27017/</a> 是否出现如下界面：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407135531155.png"  alt=""></p><h3 id="图形界面管理工具-Robo3T-安装与使用"><a href="#图形界面管理工具-Robo3T-安装与使用" class="headerlink" title="图形界面管理工具 Robo3T 安装与使用"></a>图形界面管理工具 <code>Robo3T</code> 安装与使用</h3><p><a href="https://robomongo.org/" target="_blank" rel="noopener">官网地址</a></p><p><a href="https://studio3t.com/download/" target="_blank" rel="noopener">Studio windows下载地址</a></p><p><a href="https://robomongo.org/download" target="_blank" rel="noopener">Robo 3T下载</a></p><p>进入安装页面后选择 <code>easy</code> 版本 ，然后选择你喜欢的主题风格，是明亮还是黑暗风格</p><p>进入图形化界面后，新建一个 <code>connection</code>，选择默认端口 <code>27017</code>，保存</p><h3 id="mongoose-中文文档"><a href="#mongoose-中文文档" class="headerlink" title="mongoose 中文文档"></a>mongoose 中文文档</h3><p><a href="https://xiaoxiami.gitbook.io/mongoose/" target="_blank" rel="noopener">参考：mongoose 4.5中文文档</a></p><p>在之前配置好的 Koa2 文件夹内（我的是koa2_learn文件夹） 打开 <code>bash</code> 界面，输入如下命令，安装 <code>mongoose</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p><strong>接下来就是配置相关了</strong></p><p>在项目根目录下创建 名为 <code>dbs</code> 的文件夹</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040714493081.png"  alt=""><br>新建一个 <code>config.js</code> 文件，配置如下代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    dbs: <span class="string">'mongodb://127.0.0.1:27017/dbs'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>dbs</code> 目录下创建 名为 <code>models</code> 的文件夹<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407145636457.png"  alt=""><br>新建一个 <code>person.js</code> 文件，配置如下代码（此时的文件名对应着之后我们的“表名”，也就是 <code>Collections</code>）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建模式 </span></span><br><span class="line"><span class="keyword">let</span> personSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">Number</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建模型</span></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose.model(<span class="string">'Person'</span>,personSchema)</span><br></pre></td></tr></table></figure><p>然后在 <code>app.js</code> 中进行导入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line"><span class="keyword">const</span> dbConfig = <span class="built_in">require</span>(<span class="string">'./dbs/config'</span>)</span><br></pre></td></tr></table></figure><p>在 <code>app.js</code> 默认注释 <code>routes</code> 后面，添加第三行连接代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes</span></span><br><span class="line">app.use(index.routes(), index.allowedMethods())</span><br><span class="line">app.use(users.routes(), users.allowedMethods())</span><br><span class="line">mongoose.connect(dbConfig.dbs,&#123;</span><br><span class="line">  useNewUrlParser:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>基本配置就结束了，现在最好是重启一下koa服务，<code>ctrl+c</code> 退出，然后输入如下命令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>出现如下界面，说明配置是没有问题的，连接成功！<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407151732459.png"  alt=""><br>接下来就是尝试写一个api试试，在 <code>users.js</code> 文件内配置如下代码</p><p>头部导入模型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入模型</span></span><br><span class="line"><span class="keyword">const</span> Person = <span class="built_in">require</span>(<span class="string">'../dbs/models/person'</span>)</span><br></pre></td></tr></table></figure><p>自定义api接口</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">'/addPerson'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//新建一个模型的实例</span></span><br><span class="line">  <span class="keyword">const</span> person = <span class="keyword">new</span> Person(&#123;</span><br><span class="line">    name: ctx.request.body.name,</span><br><span class="line">    age: ctx.request.body.age</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> code</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> person.save()</span><br><span class="line">    code=<span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    code=<span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  ctx.body=&#123;</span><br><span class="line">    code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>调用接口。 <code>curl</code> 是一个shell 命令，  <code>-d</code>命令表示是 <code>post</code> 请求 ，接下来是数据项，最后是api接口地址</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">'name=chocolate&amp;age=20'</span> http:<span class="comment">//localhost:3000/users/addPerson</span></span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407162123495.png"  alt=""><br>此时，打开Robo 3T，刷新一下我们的数据库，就能发现多了一个 <code>dbs</code><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407162222285.png"  alt=""><br>查看一下，是否有对应写入数据：<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040716231684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>上述过程，基本上把我们的后端服务和数据库进行了打通，后续我们只需要套着之前的例子来就好了，接下来再展示写一个api，因为上文是增加操作，也就是写操作，下文我们再来个读操作吧。</p><p>依旧是在 <code>users.js</code> 中加入如下代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据库读取api</span></span><br><span class="line">router.post(<span class="string">'/getPerson'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> Person.findOne(&#123;<span class="attr">name</span>:ctx.request.body.name&#125;)</span><br><span class="line">  <span class="keyword">const</span> results = <span class="keyword">await</span> Person.find(&#123;<span class="attr">name</span>:ctx.request.body.name&#125;)</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">    result,</span><br><span class="line">    results</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打开 <code>bash</code> ，执行如下命令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">'name=chocolate'</span> http:<span class="comment">//localhost:3000/users/getPerson</span></span><br></pre></td></tr></table></figure><p>发现，会返回给我们json数据包，证明api接口实现<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407171844176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>最后，附上更新和删除api，亲测有效嗷</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新api</span></span><br><span class="line">router.post(<span class="string">'/updatePerson'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> Person.where(&#123;</span><br><span class="line">    name:ctx.request.body.name</span><br><span class="line">  &#125;).update(&#123;</span><br><span class="line">    age: ctx.request.body.age</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//删除api</span></span><br><span class="line">router.post(<span class="string">'/removePerson'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> Person.where(&#123;</span><br><span class="line">    name:ctx.request.body.name</span><br><span class="line">  &#125;).remove()</span><br><span class="line"></span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    code: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://xiaoxiami.gitbook.io/mongoose/" target="_blank" rel="noopener">更多知识点请参考：mongoose 4.5中文文档</a></p><h2 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h2><hr/><h3 id="cookie-和-session-引入"><a href="#cookie-和-session-引入" class="headerlink" title="cookie 和 session 引入"></a>cookie 和 session 引入</h3><p>这里就要扯到 <code>cookie</code> 和 <code>session</code>的相关知识点了，划重点啦！ </p><p>服务端的程序如何去识别客户端的状态，大家知道，http是无状态的，<a href="https://blog.csdn.net/weixin_42429718/article/details/105264747" target="_blank" rel="noopener">推荐阅读：如何学好前端，白嫖知识</a> </p><p>比如现在有个用户A，它访问了服务器程序，那服务器程序如何知道下一次再访问的时候还是A呢？</p><p>因此，对于这一块就要用到非常重要的概念，<code>session</code>，当然，这个<code>session</code>可不是浏览器的，<strong>而是服务器的</strong>，它是用来存储用户的信息的。</p><p>那么，服务器的 <code>session</code>是如何保持在客户端呢？</p><p>这个时候呢，又要引出另一个非常重要的概念，浏览器中的 <code>cookie</code> 。</p><p>综上所述，<code>cookie</code> 和 <code>session</code> 的关系是：服务端用 <code>session</code> 来保存用户的状态，然后客户端用 <code>cookie</code> 来保存 <code>session</code> ，服务器端把 <code>session</code> 种植到 <code>cookie</code> 中，然后下次访问时，<code>cookie</code> 会携带着 <code>session</code> ，进而<strong>达到一个身份认证的效果</strong>。</p><h3 id="redis概念-amp-安装"><a href="#redis概念-amp-安装" class="headerlink" title="redis概念&amp;安装"></a>redis概念&amp;安装</h3><p>上文我们知道了cookie 和 session 在浏览器和服务器端的作用，那么与我们<code>redis</code> 有什么关系呢？</p><p>想一想，既然是认证的功能，那我们服务端的<code>session</code> 应该存在哪呢，也许你会想着放入服务器端存储，放入内存当中，这确实是一种方式，没有问题，但当应用程序很大的时候，<code>session</code> 容量特别大的时候呢？例如某宝这样的呢？此时内存肯定不够用了，这个时候就需要一个容器来存储大容量的 <code>session</code> 了，此时存储数据库 <code>redis</code>就发挥了它的作用了！</p><p>关于数据库的话，上文也提到了<code>mongodb</code>，我们是不是也可以用这个呢？</p><p>这个的话，虽然也是一种方式，但我们要考虑<strong>读写性能问题</strong>，因为 <code>redis</code>是<strong>快速读写类型的数据库</strong>，使用灵活方便，是 <code>key-value</code> 型的</p><hr/><p>为了更加了解<code>redis</code>，这里我就引用官方介绍了：</p><ul><li><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p></li><li><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p></li><li><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p></li></ul><p><strong>安装教程</strong></p><p><a href="https://www.runoob.com/redis/redis-install.html" target="_blank" rel="noopener">参考：redis安装教程</a></p><p><a href="https://blog.csdn.net/u012343297/article/details/78839063?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3" target="_blank" rel="noopener">参考：windows下Redis的安装和配置–图文教程</a></p><p>在 <code>koa</code> 的 <code>bash</code>界面，执行如下命令，完成 <code>koa</code> 与 <code>redis</code> 的连接</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i koa-generic-session koa-redis</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><h3 id="启动-redis-服务"><a href="#启动-redis-服务" class="headerlink" title="启动 redis 服务"></a>启动 redis 服务</h3><p>一、[9980] 21 Apr 02:57:05.611 # Creating Server TCP listening socket 127.0.0.1:6379: bind: No error</p><p>解决方法：在命令行中运行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">redis-cli.exe</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;shutdown</span><br></pre></td></tr></table></figure><p>二、Redis (error) NOAUTH Authentication required.解决方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;auth <span class="string">"123456"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;shutdown</span><br><span class="line">not connected&gt;exit</span><br></pre></td></tr></table></figure><p>然后重新运行 <code>redis-server.exe redis.windows.conf</code> ，启动成功！</p><p><a href="https://blog.csdn.net/sweetgirl520/article/details/79001056#commentBox" target="_blank" rel="noopener">参考：Redis启动报错：Creating Server TCP listening socket 127.0.0.1:6379: bind: No error</a></p><h2 id="Nuxt-js基础"><a href="#Nuxt-js基础" class="headerlink" title="Nuxt.js基础"></a>Nuxt.js基础</h2><hr/><p>Nuxt.js 是一个基于Vue.js的通用应用框架，预设了利用Vue.js开发服务端渲染的应用所需要的各种配置。</p><p>基于Vue 2做的，包括Vue-Router，支持Vuex、Vue Server Render、vue-meta</p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NTUwMDk2LTc4NDVmMjgxYzg1NjVlNTAucG5n?x-oss-process=image/format,png#pic_center"  alt=""></p><h3 id="Nuxt-js工作流"><a href="#Nuxt-js工作流" class="headerlink" title="Nuxt.js工作流"></a>Nuxt.js工作流</h3><p>下图源自Nuxt官网，简单介绍一下它的工作流程</p><p><a href="https://nuxtjs.org/api" target="_blank" rel="noopener">更多内容，请参考：nuxtjs 英文官方文档</a></p><p><a href="https://zh.nuxtjs.org/guide" target="_blank" rel="noopener">参考：nuxtjs 中文文档</a><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407200805943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>从浏览器发出一个请求，到最终服务端渲染完成，关于Nuxt的生命周期如下：</p><ul><li><code>Incoming Request</code> 浏览器发送一个请求</li><li>服务端检查是否有 <code>nuxtServerInit</code> 配置项，有的话就会执行这个函数，其中包含一个标注： <code>Store action</code> 用来操作 <code>vuex</code></li><li>下一个环节就是中间件 <code>middleware</code> ，与路由相关，做任何你想要的功能</li><li>预验证 <code>validate()</code> 可以配合高级动态路由，做一些验证，比如是否允许跳转某个页面</li><li><code>asyncData() &amp; fetch()</code> 获取数据，前一个是用来渲染<code>vue component</code>，即 vue组件的，后一个通常用来修改 <code>vuex</code>，即 <code>Store</code>的</li><li>有了数据，模板后，最后一步就是 <code>Render</code> 渲染了，方式是 <code>SSR</code></li></ul><h3 id="Nuxt-js-安装"><a href="#Nuxt-js-安装" class="headerlink" title="Nuxt.js 安装"></a>Nuxt.js 安装</h3><p>如果没有安装vue cli的话，先全局安装一下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm/cnpm install -g @vue/cli-init</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vue init nuxt-community/koa-template nuxt_learn（这里填入你自己的文件名）</span><br></pre></td></tr></table></figure><p>安装完成后，依次执行如下命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd nuxt_learn</span><br><span class="line">npm install # Or yarn</span><br><span class="line">npm install --update-binary</span><br><span class="line">npm install ajv@^<span class="number">6</span>（可选项，如果有报warn，就装一下）</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>如果安装过程网络有问题，报错了，可以试试用 <code>cnpm</code>或者</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nrm use cnpm</span><br></pre></td></tr></table></figure><p><strong>eslint版本问题：</strong> 需要更新eslint版本<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200407212332515.png"  alt=""><br>解决：执行如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install eslint-plugin-html@^<span class="number">3</span></span><br></pre></td></tr></table></figure><p>执行完如下步骤后，最后一步，打开服务：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><strong>babel编译版本有问题：</strong> 解决办法是升级<code>backpack-core@0.3.0</code>到<code>backpack-core@0.7.0</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install backpack-core@<span class="number">0.7</span><span class="number">.0</span> --save-dev</span><br></pre></td></tr></table></figure><p>解决上述问题后，编译能成功，但是客户端依旧运行报错</p><p>解决办法是：在<code>nuxt.config.js</code>里找到<code>eslint-loader</code>将<code>ctx.isClient</code>改成<code>ctx.Client</code>就可以运行了</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408075951708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p><a href="https://www.cnblogs.com/ITtt/p/10515456.html" target="_blank" rel="noopener">参考：解决vue init nuxt-community/koa-template项目，安装报错问题</a></p><p>解决完上述问题后，执行如下指令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408082532970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408082553312.png"  alt=""><br>访问：<a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a>  出现如下界面，代表配置成功 ✿✿ヽ(°▽°)ノ✿</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408082558408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>附：微信公众号：【小狮子前端】 回复【nuxt-learn】即可获取本节源码</p><h3 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h3><p>当使用 <code>SSR</code> 时， <code>mounted</code> 只在浏览器端渲染，而<strong>在服务器端不会渲染</strong> ：浏览器通过axios请求的数据，只有 <code>created</code> 在开启SSR时会执行。</p><p>SSR原理：① 服务器端将编译好的内容（模板）下发（包括样式、内容、数据）  ② 把异步获取的数据响应给浏览器端（把交互交给浏览器来完成）</p><p><strong>SSR原理深入</strong></p><p>我们打开页面源代码，查看一下：<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408105343967.png"  alt=""><br>服务器端渲染完页面后给浏览器端的html分了几个部分，第一个是样式 <code>style</code> ，第二个是模板内容，例如上图中圈中的<font color=blue>蓝色</font>部分，第三个是服务端拿到的数据结果，例如上图中圈中的<font color=red>红色</font>部分，为什么服务端拿到的数据给到浏览器端呢？<br>这里我们得思考一个<font color=red><strong>SSR的工作原理</strong></font> 了</p><p>如果不给数据的话，就是一个静态html模板，一个<strong>静态的内容</strong>，没有任何交互，那交互是在哪完成的呢？</p><p>交互是在浏览器端完成的，也就是说浏览器端会有一个入口，进行预编译，但不会再渲染页面了，因为服务器端已经在页面渲染过一次了。<strong>它要做的是创建一个虚拟的编译结果（可以理解为虚拟dom），</strong> 和服务器端传过来的结果进行对比，如果有区别，它会重新请求数据。在nuxt项目中都是一套文件，没有特别指定是在浏览器端运行还是服务端运行，也就是SSR常说的<strong>同构</strong>，浏览器端编译虚拟dom，也依赖于 <code>vue</code> 文件，因此模板是有的，而编译这个dom，需要的是额外的数据，此数据是服务器端渲染之前请求而来的数据，如果数据不同步在浏览器端，<strong>编译出来的结果必然和服务器端编译结果不一致</strong>。 </p><p>综上，<strong>服务器端异步获取的数据会同步在浏览器端</strong>，作对比，如果对比一致的话，浏览器端就会对对应的dom结点注册事件，达到交互作用。</p><p><a href="https://nuxtjs.org/api" target="_blank" rel="noopener">更多内容，请参考：nuxtjs 英文官方文档</a></p><p><a href="https://zh.nuxtjs.org/guide" target="_blank" rel="noopener">参考：nuxtjs 中文文档</a></p><p><font color=chocolate>以上，就是我们项目搭建所需的基础知识啦，已经整理完结啦，当然还有许多地方没有提及，读者可以去查阅一些官方文档来补充更多知识，下文我们将逐步深入全栈开发过程记录，制作不易，点赞收藏评论，一键三连一波~</font></p><h2 id="项目搭建开始"><a href="#项目搭建开始" class="headerlink" title="项目搭建开始"></a>项目搭建开始</h2><hr/><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ul><li>node</li><li>vue</li><li>npm</li><li>webpack</li><li>nuxt</li></ul><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g npx</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npx create-nuxt-app loveVueApp</span><br></pre></td></tr></table></figure><p>使用 <code>npx</code> 可以帮助我们更快速的搭建项目环境，在你需要创建项目文件夹的地方 <code>shift+鼠标右键</code> 打开 <code>powershell</code> 窗口，执行上述命令，然后按照下列图片选择对应的模块：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408131621565.png"  alt=""><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408131631954.png"  alt=""><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408131650677.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408131703632.png"  alt=""><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040813172024.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408131730286.png"  alt=""><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408131810561.png"  alt=""><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408131823305.png"  alt=""><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408131845331.png"  alt=""><br>安装完成后，会提示你执行如下命令：</p><p>这里我们就执行开发环境的指令就好了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd loveVueApp</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>另附上，生产环境的指令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd loveVueApp</span><br><span class="line">npm run build</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 会有一个nuxtjs的图标出现，代表环境搭配成功 ✿✿ヽ(°▽°)ノ✿</p><p>此时，再 <code>ctrl+c</code> 退出当前服务</p><p>执行如下命令，重新安装一下，防止版本问题等</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install  --update-binary</span><br></pre></td></tr></table></figure><p>重装之后，再跑一次服务，看能不能打开界面</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h3 id="增加-babel-node-处理（使用ES6的import指令问题）"><a href="#增加-babel-node-处理（使用ES6的import指令问题）" class="headerlink" title="增加 babel-node 处理（使用ES6的import指令问题）"></a>增加 babel-node 处理（使用ES6的import指令问题）</h3><p>创建好我们的基本项目后，我们还需要对我们所需要的模块进行更改。</p><p>例如，对应目标文件的第一行代码：<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408154705542.png"  alt=""><br>改为如下代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Koa  <span class="keyword">from</span> <span class="string">'koa'</span></span><br></pre></td></tr></table></figure><p>于是，就会出现报错，无法识别<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408154830122.png"  alt=""></p><p>在上文讲解 <code>nuxtjs</code>基础 我们是可以直接用 <code>import</code> 操作的，但当我们使用官方脚手架时，是没有处理这个 <code>bug</code> 的。下面来解释一下为什么会出现这个问题：</p><p>当我们使用命令 <code>npm run dev</code> 的时候，其实是用了 <code>npm</code> 的 <code>script</code> 的方法，如下图所示：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408155247326.png"  alt=""></p><p>可见使用了 <code>node</code>，并且不支持 <code>import</code> 操作，上文是因为使用了 <code>babel</code> 进行了处理，在这里官方脚手架时使用 <code>node</code> 来启动服务，没有经过 <code>babel</code> 处理，因此就不会识别 <code>import</code> 指令了。</p><p><strong>解决上述问题</strong></p><p>上文提到了是因为没有 <code>babel</code>处理，执行服务程序，那就自己加上去咯，具体如下：</p><p>在 <code>dev</code> 和 <code>start</code> 后面添加 <code>--exec babel-node</code></p><p>或者直接使用下面代码覆盖你的 <code>scripts</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"cross-env NODE_ENV=development nodemon server/index.js --watch server --exec babel-node"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"nuxt build"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"cross-env NODE_ENV=production node server/index.js --exec babel-node"</span>,</span><br><span class="line">    <span class="string">"generate"</span>: <span class="string">"nuxt generate"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>然后，在根目录下创建一个 <code>.babelrc</code> 的配置文件，然后给它指定一个指令集</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>:[<span class="string">"es2015"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了代码还不行，还要再安装插件，执行如下命令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install babel-preset-es2015</span><br><span class="line">npm install babel-cli -S</span><br></pre></td></tr></table></figure><p>好了，有了 <code>babel-node</code> 后我们就能启动服务程序了，改成了我们常用的 <code>ES6</code>语法了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>访问：<a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 会有一个nuxtjs的图标出现，代表环境搭配成功 ✿✿ヽ(°▽°)ノ✿</p><h3 id="解决-sass-导致编译出错问题"><a href="#解决-sass-导致编译出错问题" class="headerlink" title="解决 sass 导致编译出错问题"></a>解决 sass 导致编译出错问题</h3><p>这个问题也依旧是脚手架带来的问题，解决方式就是安装几个插件，执行命令如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install sass-loader node-sass</span><br></pre></td></tr></table></figure><p>PS：可能会有下述 <code>warn</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install eslint@^(版本号)  <span class="comment">//（注意，这里是当你出现对应warn才执行）</span></span><br></pre></td></tr></table></figure><p>我的是这种警告，因此依葫芦画瓢，执行下述命令<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408162852228.png"  alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install sass@^<span class="number">1.3</span><span class="number">.0</span> fibers@&gt;= <span class="number">3.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h3 id="辅助工具安装"><a href="#辅助工具安装" class="headerlink" title="辅助工具安装"></a>辅助工具安装</h3><ul><li>MongoDB</li><li>redis</li><li>Robo 3T</li></ul><p>（上文基础部分有介绍安装教程，可以往回看一看对应模块 ↑）</p><h2 id="远程仓库常用指令（整理）"><a href="#远程仓库常用指令（整理）" class="headerlink" title="远程仓库常用指令（整理）"></a>远程仓库常用指令（整理）</h2><ul><li><p>查看分支：<code>git branch</code></p></li><li><p>查看项目的分支们(包括本地和远程) <code>git branch -a</code></p></li><li><p>创建分支：<code>git branch &lt;name&gt;</code></p></li><li><p>切换分支：<code>git checkout &lt;name&gt;</code></p></li><li><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p></li><li><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p></li><li><p>提交 git commit -m ‘简介’</p></li><li><p>git push -u origin master</p></li></ul><h2 id="首页开发"><a href="#首页开发" class="headerlink" title="首页开发"></a>首页开发</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li>模板设计（解决复用问题）</li></ul><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040817250239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><ul><li>组件设计（如何拆分组件）</li></ul><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408174830905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br><strong>如何节省网络请求？</strong></p><p>上述流程图共进行了两次请求，另外，异步获取数据时，还会有<code>闪一下</code>，影响用户体验，同时浪费一次网络请求。解决办法就是当浏览器去请求服务器的时候，当浏览器去请求文档的时候，服务端 <code>ip</code>已经知道了，那个时候就可以拿到对应的城市，立即返回数据给浏览器。做法就是通过 <code>vuex</code> 来同步状态，然后通过 <code>SSR</code> 异步请求就能得到数据。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040818365254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>类似于上文流程图，也是可以通过 <code>vuex</code> 来做<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408183829795.png"  alt=""><br>属于静态模块，不需要我们异步获取数据，直接用 <code>SSR</code> 下发一下就ok。</p><ul><li>数据结构设计（依赖于数据和组件）</li></ul><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409171816616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br><code>pois表</code>  <strong>城市推荐数据库</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409171908774.png"  alt=""></p><ul><li>接口设计（与数据结构相对应）</li></ul><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409172047435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h3 id="首页开发Header-城市定位服务设计"><a href="#首页开发Header-城市定位服务设计" class="headerlink" title="首页开发Header-城市定位服务设计"></a>首页开发Header-城市定位服务设计</h3><p>根据 <code>Header</code> 布局情况来看的话，我们在<code>components</code>文件夹下创建如下几个文件夹和文件（水印遮住的是 <code>README</code>）</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408192534453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p>导入css，然后打开 <code>nuxt.config.js</code> 进行配置<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408191205311.png"  alt=""></p><h2 id="项目开发可能遇到问题"><a href="#项目开发可能遇到问题" class="headerlink" title="项目开发可能遇到问题"></a>项目开发可能遇到问题</h2><hr/><p><strong><font color=red>重要提醒！</font></strong></p><p>本篇文章能详细概述的地方有限，所以下文将会以讲重点部分为主，其余部分请参考本参考源码，已经开放，开发过程中按照分支进行开发，然后合并到 <code>master</code> 分支</p><p><a href="https://github.com/Chocolate1999/Vue-family-bucket-SSR-Koa2-full-stack-development-from-Meituan" target="_blank" rel="noopener">仓库の传送门（戳一戳）</a></p><p>收藏 <code>star</code> 一波，✿✿ヽ(°▽°)ノ✿</p><h3 id="关于项目中SMTP服务功能配置问题"><a href="#关于项目中SMTP服务功能配置问题" class="headerlink" title="关于项目中SMTP服务功能配置问题"></a>关于项目中SMTP服务功能配置问题</h3><p>如下图，所示，我们首先登陆自己的QQ，打开邮箱，然后去打开下面两项服务<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409181256509.png"  alt=""><br>在  <code>server/dbs/config.js</code> 文件内更改为你自己的授权密钥和邮箱即可<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409182212470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p><strong>引入 mongoose</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure><p>配置 <code>users</code> 接口</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install koa-router koa-redis nodemailer</span><br></pre></td></tr></table></figure><p>配置 <code>axios</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>配置 <code>passport</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install koa-passport passport-local</span><br></pre></td></tr></table></figure><h3 id="关于项目中登录注册接口问题"><a href="#关于项目中登录注册接口问题" class="headerlink" title="关于项目中登录注册接口问题"></a>关于项目中登录注册接口问题</h3><p><code>passport</code> 包内有 <code>isAuthenticated()</code>方法，因此在文档源码中没有定义过。</p><p><code>passport</code>会把用户的信息对象放到 <code>session</code> 对象里面去，也就是 <code>passport</code> 会存储在 <code>session</code> 中，例如如下，如果是登录状态的话，那么session会有 <code>passport</code>，而 <code>passport</code> 会有 <code>user</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//判断是否是登录状态</span></span><br><span class="line"><span class="keyword">if</span> (ctx.isAuthenticated()) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;username, email&#125; = ctx.session.passport.user</span><br><span class="line">  ctx.body=&#123;</span><br><span class="line">    user:username,</span><br><span class="line">    email</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>users.js</li></ul><h3 id="server文件夹-index-js文件中-加载相关包"><a href="#server文件夹-index-js文件中-加载相关包" class="headerlink" title="server文件夹 index.js文件中 加载相关包"></a>server文件夹 index.js文件中 加载相关包</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mongoose <span class="keyword">from</span> <span class="string">'mongoose'</span></span><br><span class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'koa-bodyparser'</span></span><br><span class="line"><span class="keyword">import</span> session <span class="keyword">from</span> <span class="string">'koa-generic-session'</span></span><br><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">'koa-redis'</span></span><br><span class="line"><span class="keyword">import</span> json <span class="keyword">from</span> <span class="string">'koa-json'</span></span><br><span class="line"><span class="keyword">import</span> dbConfig <span class="keyword">from</span> <span class="string">'./dbs/config'</span></span><br><span class="line"><span class="keyword">import</span> passport <span class="keyword">from</span> <span class="string">'./interface/utils/passport'</span></span><br><span class="line"><span class="keyword">import</span> users <span class="keyword">from</span> <span class="string">'./interface/users'</span></span><br><span class="line"><span class="keyword">import</span> geo <span class="keyword">from</span> <span class="string">'./interface/geo'</span></span><br><span class="line"><span class="keyword">import</span> search <span class="keyword">from</span> <span class="string">'./interface/search'</span></span><br><span class="line"><span class="keyword">import</span> categroy <span class="keyword">from</span> <span class="string">'./interface/categroy'</span></span><br><span class="line"><span class="keyword">import</span> cart <span class="keyword">from</span> <span class="string">'./interface/cart'</span></span><br></pre></td></tr></table></figure><p>加载指令：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install mongoose koa-bodyparser koa-generic-session koa-redis koa-json</span><br></pre></td></tr></table></figure><h3 id="Cannot-read-property-‘post’-of-undefined-问题解决"><a href="#Cannot-read-property-‘post’-of-undefined-问题解决" class="headerlink" title="Cannot read property ‘post’ of undefined 问题解决"></a>Cannot read property ‘post’ of undefined 问题解决</h3><p>注册那一个模块那里，我一点发送验证码，然后就报了这个错误，一开始以为接口写错了，还测试了一下，原来是因为 <code>axios</code> 没有在 <code>nuxt</code> 脚手架中配置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Cannot read property <span class="string">'name'</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p><code>nuxt.config.js</code> 文件中配置如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    <span class="string">'@nuxtjs/axios'</span>,</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  axios: &#123;</span><br><span class="line">    <span class="comment">// proxyHeaders: false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决之后，发送验证码，如下结果，有邮件发送过来 ✿✿ヽ(°▽°)ノ✿<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200410101314585.png"  alt=""></p><h3 id="关于-win10-redis-报错-Permission-denied"><a href="#关于-win10-redis-报错-Permission-denied" class="headerlink" title="关于 win10 redis 报错 Permission denied"></a>关于 win10 redis 报错 Permission denied</h3><p>同样也是注册页面，当我们注册后，点击同意协议并注册，发现无法跳转到登录界面，而提示 <code>已注册</code> ，看了半天，提示服务错误，于是一开打redis命令窗，报了这个错误，原来是默认设置了<strong>只可读不可写</strong>，按如下方式增加权限，解决了问题 ✿✿ヽ(°▽°)ノ✿</p><p>解决：去Redis的rdb文件查看文件属性，增加写入权限<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200410111551414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br><a href="https://blog.csdn.net/u010049198/article/details/89715009" target="_blank" rel="noopener">参考：Redis在Windows下的坑</a></p><h3 id="关于win10-mongodb-导入-bat文件问题"><a href="#关于win10-mongodb-导入-bat文件问题" class="headerlink" title="关于win10 mongodb 导入.bat文件问题"></a>关于win10 mongodb 导入.bat文件问题</h3><p>网上说用如下指令，但是我还是没有导入成功，说是不存在这指令，但之前数据库都导入了 <code>users</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mongoimport -d student -c areas areas.dat</span><br></pre></td></tr></table></figure><p>于是，我就打开了 <code>Studio 3T</code> 来试着导入，还算是成功了吧</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200410115105370.png"  alt=""><br>我的做法是直接在左边那个 <code>Collections</code> 文件夹直接右键 选择 <code>Add</code> 操作，然后导入 <code>.dat</code>文件，不过导完之后会有后缀出现，于是我就重命名了一下。虽然看起来有点傻傻的做法，但也算是解决了吧 ✿✿ヽ(°▽°)ノ✿<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200410115134385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h3 id="关于-geo服务-接口签名"><a href="#关于-geo服务-接口签名" class="headerlink" title="关于 geo服务 接口签名"></a>关于 geo服务 接口签名</h3><p><a href="http://cp-tools.cn/sign" target="_blank" rel="noopener">http://cp-tools.cn/sign</a></p><h3 id="关于定位服务及切换城市-geo-bug解决"><a href="#关于定位服务及切换城市-geo-bug解决" class="headerlink" title="关于定位服务及切换城市 geo bug解决"></a>关于定位服务及切换城市 geo bug解决</h3><p>在城市定位  <code>geo</code> 分支那里，报了如下两个错误，可让我焦头烂额啊，终于，找到了解决办法，特来写此模块，记录一下 ✿✿ヽ(°▽°)ノ✿</p><p><font color=red>① 报错Classic mode for store/ is deprecated and will be removed in Nuxt 3.</font></p><p><font color=red>② Error occurred when calling nuxtServerInit:  socket hang up</font></p><p>对<strong>第一个问题</strong>出现这种错误的原因是：nuxt3版本中已经移除了对原始vuex这种编程，出现这种错误的代码如下：</p><p>解决的办法如下： store 目录下的每个 .js 文件会被转换成为状态树指定命名的子模块 （当然，index 是根模块）。</p><p>（以下代码亲测有效，直接覆盖你的代码即可）</p><p>首先是目录结构修改，最新版的已经不需要另外加一个 <code>models</code> 文件夹了。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200410192219410.png"  alt=""></p><p><code>index.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="keyword">async</span> nuxtServerInit(&#123;</span><br><span class="line">    commit</span><br><span class="line">  &#125;,&#123;req,app&#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;status,<span class="attr">data</span>: &#123;province,city&#125;&#125; = <span class="keyword">await</span> app.$axios.get(<span class="string">'/geo/getPosition'</span>)</span><br><span class="line">    commit(<span class="string">'geo/setPosition'</span>,status===<span class="number">200</span>?&#123;city,province&#125;:&#123;<span class="attr">city</span>:<span class="string">''</span>,<span class="attr">province</span>:<span class="string">''</span>&#125;)      </span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="attr">status</span>:status2, <span class="attr">data</span>: &#123;menu&#125;&#125; = <span class="keyword">await</span> app.$axios.get(<span class="string">'/geo/menu'</span>)</span><br><span class="line">    commit(<span class="string">'home/setMenu'</span>,status2===<span class="number">200</span>?menu:[])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>geo.js</code> 文件无需修改</p><p>对<strong>第二个问题</strong>，多半是因为你写好的 <code>geo</code> 相关接口没有在<code>serve/index.js</code>中进行导入和配置使用（我就是因为这个）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> geo <span class="keyword">from</span> <span class="string">'./utils/geo'</span></span><br><span class="line">app.use(geo.routes()).use(geo.allowedMethods())</span><br></pre></td></tr></table></figure><p>具体导入位置如下：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200410192529985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200410192546969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p><a href="https://blog.csdn.net/Umbrella_Um/article/details/99711310" target="_blank" rel="noopener">参考：美团项目 — 定位服务及切换城市5</a></p><p><a href="https://blog.csdn.net/weixin_44638823/article/details/103546428?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2" target="_blank" rel="noopener">参考：nuxtjs中使用SSR开发关于前端vuex请求后台的问题</a></p><h3 id="关于搜索框请求次数问题"><a href="#关于搜索框请求次数问题" class="headerlink" title="关于搜索框请求次数问题"></a>关于搜索框请求次数问题</h3><p>我们当然不能没输入一个字符，就请求一次接口，因此我们需要弄一个延时函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install lodash</span><br></pre></td></tr></table></figure><p>引入库</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br></pre></td></tr></table></figure><h3 id="关于切换城市模块优化与实现"><a href="#关于切换城市模块优化与实现" class="headerlink" title="关于切换城市模块优化与实现"></a>关于切换城市模块优化与实现</h3><p>首先明确一载入切换城市界面，哪个是要进行请求的，那就是省份（第一级），此时可以使用ssr进行服务端渲染，页面载入后也跟着进行载入，但这里就直接使用vue中的Mouted生命函数完成这里的axios请求 ↓</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">      status,</span><br><span class="line">      data: &#123; province &#125;</span><br><span class="line">    &#125; = <span class="keyword">await</span> self.$axios.get(<span class="string">"/geo/province"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status === <span class="number">200</span>) &#123;</span><br><span class="line">      self.province = province.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: item.id,</span><br><span class="line">          label: item.name</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>联动逻辑，使用watch监听用户选择了什么省份</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听pvalue值，当省份发生改变的时候，可选城市也要跟着改变（联动）</span></span><br><span class="line">watch:&#123;</span><br><span class="line">  pvalue:<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">newPvalue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self=<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> &#123;status,<span class="attr">data</span>:&#123;city&#125;&#125;=<span class="keyword">await</span> self.$axios.get(<span class="string">`/geo/province/<span class="subst">$&#123;newPvalue&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">if</span>(status===<span class="number">200</span>)&#123;</span><br><span class="line">      self.city=city.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value:item.id,</span><br><span class="line">          label:item.name</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self.cvalue=<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>注意select下拉框的设计，如果你不设置 <code>label</code> 显示的还是 <code>value</code> 的值，但是如果你设置了 <code>label</code> 那输入框显示的就是 <code>label</code> 的值，但是你 <code>v-model</code> 拿的还是你 <code>value</code> 的值，所以在省份中复制也是将 <code>id</code> 赋值给 <code>value</code> 的，所以参数正确！<br>会二级联动，三级联动还会难吗？毕竟现在你只需要重点思考逻辑上的代码，而 <code>DOM</code> 结构E-UI已经随随便便完成了，只剩下你关联他们的代码而已</p><p><a href="https://blog.csdn.net/Umbrella_Um/article/details/100191306" target="_blank" rel="noopener">参考：美团项目 — 切换城市 7</a></p><h2 id="通过项目挖掘知识点（整理）"><a href="#通过项目挖掘知识点（整理）" class="headerlink" title="通过项目挖掘知识点（整理）"></a>通过项目挖掘知识点（整理）</h2><h3 id="koa2中的ctx是什么？"><a href="#koa2中的ctx是什么？" class="headerlink" title="koa2中的ctx是什么？"></a>koa2中的ctx是什么？</h3><p>为了试图搞明白，用console.log将它输出</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123; request:</span><br><span class="line">   &#123; method: <span class="string">'GET'</span>,</span><br><span class="line">     url: <span class="string">'/'</span>,</span><br><span class="line">     header:</span><br><span class="line">      &#123; host: <span class="string">'localhost:3000'</span>,</span><br><span class="line">        connection: <span class="string">'keep-alive'</span>,</span><br><span class="line">        <span class="string">'cache-control'</span>: <span class="string">'max-age=0'</span>,</span><br><span class="line">        <span class="string">'upgrade-insecure-requests'</span>: <span class="string">'1'</span>,</span><br><span class="line">        <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span>,</span><br><span class="line">        accept: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</span><br><span class="line">        <span class="string">'accept-encoding'</span>: <span class="string">'gzip, deflate, sdch, br'</span>,</span><br><span class="line">        <span class="string">'accept-language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span> &#125; &#125;,</span><br><span class="line">  response:</span><br><span class="line">   &#123; status: <span class="number">200</span>,</span><br><span class="line">     message: <span class="string">'OK'</span>,</span><br><span class="line">     header:</span><br><span class="line">      &#123; <span class="string">'content-type'</span>: <span class="string">'text/plain; charset=utf-8'</span>,</span><br><span class="line">        <span class="string">'content-length'</span>: <span class="string">'25'</span> &#125; &#125;,</span><br><span class="line">  app: &#123; subdomainOffset: <span class="number">2</span>, proxy: <span class="literal">false</span>, env: <span class="string">'development'</span> &#125;,</span><br><span class="line">  originalUrl: <span class="string">'/'</span>,</span><br><span class="line">  req: <span class="string">'&lt;original node req&gt;'</span>,</span><br><span class="line">  res: <span class="string">'&lt;original node res&gt;'</span>,</span><br><span class="line">  socket: <span class="string">'&lt;original node socket&gt;'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见它主要包括 <code>request</code> 和  <code>response</code> 两部分。</p><blockquote><div>ctx是context的缩写中文一般叫成上下文，这个在所有语言里都有的名词，可以理解为上(request)下(response)沟通的环境，所以koa中把他们两都封装进了ctx对象，koa官方文档里的解释是为了调用方便，ctx.req=ctx.request,ctx.res=ctx.response，类似linux系统中的软连接？最终执行还是request和response对象</blockquote><blockquote><div>body是http协议中的响应体，header是指响应头ctx.body = ctx.res.body = ctx.response.body</div></blockquote><p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。</p><p><code>Context.response.body</code> 属性就是发送给用户的内容。</p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = require(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = new Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = ctx =&gt; &#123;</span><br><span class="line">  ctx.response.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，main函数用来设置 <code>ctx.response.body</code> 。然后，使用 <code>app.use</code> 方法加载main函数。</p><p>你可能已经猜到了，ctx.response代表 HTTP Response。同样地，ctx.request代表 HTTP Request。</p><p>运行这个 demo，访问 <a href=" http://127.0.0.1:3000">http://127.0.0.1:3000 </a>，现在就可以看到”Hello World”了。</p><p><a href="https://www.cnblogs.com/lfri/p/11936231.html" target="_blank" rel="noopener">参考：koa2中的ctx是什么？</a></p><h3 id="koa2中-query-和-querystring"><a href="#koa2中-query-和-querystring" class="headerlink" title="koa2中 query 和 querystring"></a>koa2中 query 和 querystring</h3><p>在 koa 中，GET请求获取请求数据request对象中的 query 方法和 querystring 方法， query方法返回的是格式化好的参数，querystring 方法返回的是请求字符串。</p><p><strong>koa2如何获取get方式的路由参数，比如xxx？name=123 获取name值</strong></p><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">ctx.request.query</span><br><span class="line"><span class="comment">// =&gt; &#123;name: '123'&#125;</span></span><br><span class="line">ctx.query</span><br><span class="line"><span class="comment">// =&gt; &#123;name: '123'&#125;</span></span><br></pre></td></tr></table></figure><p><code>ctx.request</code>  是 <code>Koa</code> 请求对象。可以通过 <code>querystring</code>  获取请求路径中的 <code>query</code> 字符串，通过 <code>query</code> 获取格式化好的参数。<br><code>ctx.query</code> 是 <code>route.query</code> 的别名。</p><p><a href="https://www.jianshu.com/p/a37fd499f0c1" target="_blank" rel="noopener">阅读过：nuxt - nuxtServerInit &amp; 页面渲染前的store处理 &amp; context</a></p><h3 id="koa2-使用passport权限认证中间件"><a href="#koa2-使用passport权限认证中间件" class="headerlink" title="koa2 使用passport权限认证中间件"></a>koa2 使用passport权限认证中间件</h3><p><a href="https://segmentfault.com/a/1190000011557953" target="_blank" rel="noopener">参考：koa2 使用passport权限认证中间件</a></p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p><a href="http://www.imooc.com/wenda/detail/591712" target="_blank" rel="noopener">更多内容参考：了解护照序列化反序列化</a></p><p>故名思议就是将结构化的对象转换为字节序列，反之就叫做反序列化。</p><p><strong>为什么要序列化和反序列化？</strong></p><p>内存当中的对象是结构化的，当你需要将这个对象在网络当中传输的时候，或者要保存到文件或者数据库当中的时候，你就需要将它序列化成字节流，便于处理。</p><p>而反过来，传输过去之后，或者从文件和数据库里读取出来的时候，又要重新构建恢复出原来的对象。</p><p>类比就是，比如我们打电话，电线不能直接传声音，需要把声音转换为电流，过去再把电流转换为声音。</p><h3 id="为什么utils-axios-js-要创建一个实例"><a href="#为什么utils-axios-js-要创建一个实例" class="headerlink" title="为什么utils/axios.js 要创建一个实例"></a>为什么utils/axios.js 要创建一个实例</h3><p>以下内容参考： <a href="https://zh.nuxtjs.org/guide/async-data" target="_blank" rel="noopener">nuxt.js 官方中文文档</a></p><p>如果您的项目中直接使用了 <code>node_modules</code> 中的 <code>axios</code> ，并且使用 <code>axios.interceptors</code> 添加拦截器对请求或响应数据进行了处理，确保使用 <code>axios.create</code> 创建实例后再使用。否则多次刷新页面请求服务器，服务端渲染会重复添加拦截器，导致数据处理错误。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">import axios from 'axios'</span><br><span class="line"><span class="keyword">const</span> myaxios = axios.create(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line">myaxios.interceptors.response.use(function (response) &#123;</span><br><span class="line">  <span class="keyword">return</span> response.data</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><hr/><p><font color="Tomato"><strong>如若本文有瑕疵需修改的地方，请提出来，谢谢您的贡献！</strong></font></p><p><font color=chocolate>欢迎关注微信公众号：小狮子前端Vue</font></p><p>谢谢您的支持！✿✿ヽ(°▽°)ノ✿</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> 美团 </tag>
            
            <tag> SSR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15个前端攻城狮必备的学习网站 | 你知道几个？（附视频介绍）</title>
      <link href="/posts/50975/"/>
      <url>/posts/50975/</url>
      
        <content type="html"><![CDATA[<h2 id="前端开发所需掌握知识点概要"><a href="#前端开发所需掌握知识点概要" class="headerlink" title="前端开发所需掌握知识点概要"></a>前端开发所需掌握知识点概要</h2><ul><li><p>HTML&amp;CSS：</p><p>  对Web标准的理解（结构、表现、行为）、浏览器内核、渲染原理、依赖管理、兼容性、CSS语法、层次关系，常用属性、布局、选择器、权重、盒模型、Hack、CSS预处理器、<br>  CSS3、Flexbox、CSS Modules、Document flow、BFC、HTML5（离线 &amp; 存储、Histoy,多媒体、WebGL\SVG\Canvas）；        </p></li><li><p>JavaScript：</p><p>  数据类型、运算、对象、Function、继承、闭包、作用域、事件、Prototype、RegExp、JSON、Ajax、DOM、BOM、<br>  内存泄漏、跨域、异步请求、模板引擎、模块化、Flux、同构、算法、ECMAScript6、Nodejs、HTTP、</p></li><li><p>其他：</p><p>  主流MVVM框架(React\Vue\Angular)、Hybrid App\React Native\Weex、TypeScript、RESTFul、WEB安全、前端工程化、依赖管理、性能优化、<br>  重构、团队协作、可维护、易用性、SEO、UED、前端技术选型、快速学习能力等；</p></li></ul><h2 id="视频介绍"><a href="#视频介绍" class="headerlink" title="视频介绍"></a>视频介绍</h2><p><a href="https://www.bilibili.com/video/BV1mk4y1d7Vm" target="_blank" rel="noopener">视频传送门~</a></p><h2 id="前端学习网站推荐"><a href="#前端学习网站推荐" class="headerlink" title="前端学习网站推荐"></a>前端学习网站推荐</h2><p>以下排名不分先后</p><ul><li><p>OSCHINA：     <a href=" https://www.oschina.net/">https://www.oschina.net/</a>（中文开源技术交流社区）</p></li><li><p>九章算法：    <a href="https://www.jiuzhang.com/" target="_blank" rel="noopener"> https://www.jiuzhang.com/</a>（硅谷顶尖IT人员教授面试技巧）</p></li><li><p>LintCode：    <a href=" https://www.lintcode.com/"> https://www.lintcode.com/</a>（空前强大的在线刷题系统）</p></li></ul><ul><li><p>CSDN ：   <a href=" https://chocolate.blog.csdn.net/"> https://chocolate.blog.csdn.net/</a>（优秀的博客）</p></li><li><p>掘金： <a href="https://juejin.im/" target="_blank" rel="noopener">https://juejin.im/</a>（帮助开发者成长的社区）</p></li><li><p>开源社区_深度开源：<a href="https://www.open-open.com/" target="_blank" rel="noopener">https://www.open-open.com/</a>（一切开源）</p></li><li><p>慕课网：       <a href=" http://www.imooc.com/">http://www.imooc.com/</a>（程序员的梦工厂）</p></li><li><p>div.io：         <a href=" http://div.io">http://div.io</a>（高质量前端资源汇聚）</p></li><li><p>推酷： <a href="https://www.tuicool.com/" target="_blank" rel="noopener">https://www.tuicool.com/ </a> （IT人专属个性阅读社区）</p></li><li><p>Hacker News： <a href="https://news.ycombinator.com/news" target="_blank" rel="noopener">https://news.ycombinator.com/news</a>（新闻）</p></li><li><p>InfoQ：       <a href=" https://www.infoq.cn/">https://www.infoq.cn/</a>（软件开发及领域知识传播-中文版）</p></li><li><p>w3cplus：    <a href=" http://www.w3cplus.com/"> http://www.w3cplus.com/</a>（国内前端行业的技术博客）</p></li><li><p>Stack Overflow： <a href=" http://stackoverflow.com/">http://stackoverflow.com/</a>（为开发人员提供支持）</p></li><li><p>w3school：    <a href=" http://www.w3school.com.cn/">http://www.w3school.com.cn/</a>（领先的 Web 技术教程 - 全部免费）</p></li><li><p>MDN：     <a href=" https://developer.mozilla.org/zh-CN/docs/Web/">https://developer.mozilla.org/zh-CN/docs/Web/</a>（Web 开发技术分享）</p></li></ul><h2 id="官方文档推荐"><a href="#官方文档推荐" class="headerlink" title="官方文档推荐"></a>官方文档推荐</h2><ul><li><a href="https://docs.huihoo.com/jquery/jquery-fundamentals/zh-cn/index.html" target="_blank" rel="noopener">jQuery 基本原理</a></li><li><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门 作者：阮一峰</a></li><li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="noopener">JavaScript 秘密花园</a></li><li><a href="http://css.doyoe.com/" target="_blank" rel="noopener">web前端开发参考手册系列之CSS参考手册</a></li><li><a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">JavaScript 教程</a></li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>笔记分享：<a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes" target="_blank" rel="noopener">传送门</a></p><p>或者关注微信公众号：【小狮子前端Vue】 回复【笔记】即可获取礼包</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网站推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【长文总结】2020 从零到博客专家  过去的我，现在的我，将来的我</title>
      <link href="/posts/37335/"/>
      <url>/posts/37335/</url>
      
        <content type="html"><![CDATA[<h3 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h3><hr/><p>其实对于2020年我一直想写一篇长文总结的，从2020年开始到现在已经过去了3个月了，这3个月期间我看了许多篇别人对于2019的总结以及对2020年自己的新打算。我的灵感一直都挺多的，如果写一篇对于2019的总结的话，我自己觉得好像说来说去只能说点心灵鸡汤来激励自己2020年继续加油努力，想着也没有一件可以用时间线的形式来说的事情，2019年或许感受颇多的就是对于ACM方面，我已经写了一篇总结了，继续写也没有什么新的思绪在这里面了。</p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104091170" target="_blank" rel="noopener">推荐阅读：关于我的大学ACM江湖</a></p><p>我在这里整理了一份目录，读者可以选择性去阅读，也方便自己将来进行查阅，回忆过去大学里的点点滴滴。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200313140803866.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p>@[toc]</p><h3 id="我开始写博客的原因"><a href="#我开始写博客的原因" class="headerlink" title="我开始写博客的原因"></a>我开始写博客的原因</h3><hr/><ul><li>受老师的影响</li></ul><p>这里主要是大一期间，入大学的开学典礼，给我们宣传acm的学长学姐，多次提到了一位老师——伟帅（貌似名字在这里属于关键字，无法引用，就用学长学姐们常说的伟帅好了）。那时候老师提到了有一个自己的博客，坚持写博客受益终身，我就好奇搜了搜他的博客，看到内容后，我当时就惊呆了，老师都出了好多书了…</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020031312325513.png"  alt=""><br><a href="https://blog.csdn.net/LoveLion" target="_blank" rel="noopener">访问伟帅の博客</a></p><p>另外就是大学里班主任的影响，在一次班会提及过的，大概意思就是一位学长，原本迷茫不止，后来终于醒悟，去网上自学，不懂的就去找博客，然后不断写博客，最后成功的例子。虽然不记得原话了，但是当时听完后我自己的总结依旧还记得：写博客，坚持写，走向成功！ 于是我就注册了一个csdn博客，从下面归档可以看到，我当初应该就是2018年10月份开始使用csdn，当初写了了一篇博客后，就断更了。当初就是觉得自己挺迷茫的，没啥方向，听了班会课后，打了一次鸡血，就兴奋地写了一篇自己的博客，但是激情还是抵挡不住自己的懒惰，于是断更了几个月。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200313123904523.png"  alt=""><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200313124031751.png"  alt=""></p><ul><li>见证自己成长的记录</li></ul><p>从上文归档那里，可以看到，2019年2月份我的博客开始写的挺多的了，那时候绝大多数文章都是关于算法的文章，因为当初报名参加了蓝桥杯大学生程序设计竞赛（省赛），当初校内选拔拿到了去正式比赛的名额，于是那个寒假我就专注于刷题。但是题可能会遗忘，于是我又想到了csdn，将题目和题解思路全部记录上去，这样我以后也可以翻阅，总结自己的知识点以及存题。<font color=red>就在这时，我就养成了坚持写博客的好习惯！</font><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200313124704387.png"  alt=""><br>从归档即可知道，从2019年2月份开始，我每个月都会写博客，写博客已经是我的习惯了。</p><ul><li>积累知识点</li></ul><p>从一开始我只是把博客当做自己刷题的记录，到现在，我将它作为知识的记录，俗话说：“好记性不如烂笔头”！作为程序员来说，学习的知识多的同时也挺杂，如果没有一个记录，很容易遗忘，所以写在博客里，可以用来及时复习查阅，我想这应该是大部分程序员都会想到的事情。</p><ul><li>学会分享</li></ul><p>我这么坚持去写博客，也是来源于当初看到了一些优秀的博客。当初一个bug找不到，或者说一个题不会写，去网上搜，我才知道别人讲的是如此之好，讲的特别清楚，真正站在编程小白角度上去写的博客。真的从这些优秀的人上学习到了爱分享精神，自此，我也将我平常遇到的bug和一些难题都写的挺详细的，然后更加注意自己的排版与格式，端正好的态度去写好每一篇博客。</p><ul><li>增加影响力</li></ul><p>或许有些人会问，你这么坚持写博客，你图什么？我从网上一搜遍地都是相关文章，一样可以解决自己的问题，反而会花大量的时间去书写一篇博客。但是，你却忽视了写博客带来的好处，花时间是必须承认的事情，但你可以增加你在行业里的影响力，比如你在csdn写博客，能有排名，能有活跃度，能有粉丝数量，甚至你的博客足够优秀，你能获得“<code>博客专家</code>”的荣誉称号！这也是为什么我今天才开始写这篇总结博客的原因。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200313130750400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>另外，你去找工作，找实习，拥有一个个人博客也是加分项，我曾经阅读过关于找工作的一篇博文，内容就是面试笔试不是特别理想，就因为看到了他的优秀博客，公司认为他只是遗忘了许多只是，要捡起来也是挺容易的，最终还是选择给了他offer！真是受益颇多。</p><ul><li>积累名气</li></ul><p>名气高了，自然会有一些出版社看到你，找你写书，这是真的！我曾经遇到了两次出版社和我联系，还有一个就是慕课想找我写专栏，询问我研究领域与方向，但是因为学生阶段，时间还是不够，还是要加强学习，也很明白现在能力还是不够。</p><ul><li>个人追求</li></ul><p>在学校里，有打acm特别强的学长学姐，有拿到特别高薪水offer的学长学姐，有本科毕业即进腾讯的优秀学长学姐，有获得保研资格的，有拿过无数证书，奖金的等，他们都很优秀，以致于在学校里声望挺高的，可算是耳濡目染吧，我在大学就想过，我也想提升自己的影响力。我发现好像有一个博客方面的名额，我想通过写博客成为一定影响力的人，不仅是在学校，更是在行业内。现在发现，我算是成功了一点，越来越多的人访问我的博客，我的粉丝也逐渐增多，说明我还在进步！</p><h3 id="我成为博客专家的路程"><a href="#我成为博客专家的路程" class="headerlink" title="我成为博客专家的路程"></a>我成为博客专家的路程</h3><hr/><p>如下图，我在2019年9月27日第一次提交了对于博客专家的申请，那时候才知道有这种称号获取，显然，当时博客没什么影响力，内容都是比较基础的，第一次申请未能通过。狮子座的我当然不会放弃自己的追求，我将成为博客专家定为在csdn的一个目标，立志要获得这份荣誉。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020031311380142.png"  alt=""><br>原本以为自己是中奖绝缘体，但是在2020年好像运气来了，我在csdn中了第一份奖品：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200313113915501.png"  alt=""></p><p>然后在1月份去申请了博客之星，也是很幸运地晋级到了前200名，获得了“博客之星入围”的荣誉称号。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200313113930548.png"  alt=""><br>其次，在今年春节，也是挺幸运中了唯一一个的一等奖<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200313132407848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p>在2020年2月14日，我又再次去申请，因为缺乏有深度的技术文章而没有通过，可我依旧没有放弃对这份荣誉的追求，我选择沉静下来，好好去学习，研究一些深度一点的问题。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020031311401073.png"  alt=""><br>终究是<font color=red>越努力，越幸运！</font>我的文章，开始被看重，被推荐。随着我写的文章越来越多，我的访问量也是飙升，粉丝数每天都有在涨，从原本1月份刚突破100个，但现在快突破600了，而且我的总排名从最初20多万+到现在3000名左右了。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020031311405155.png"  alt="">)<img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200313122232402.png"  alt=""></p><h3 id="大学里的感情经历"><a href="#大学里的感情经历" class="headerlink" title="大学里的感情经历"></a>大学里的感情经历</h3><hr/><p>常说，大学里不拿一次奖学金，不挂一次科，不谈一次恋爱是不完美的。有些同学还为此改过网名，比如四级不过不改名，六级不过不改名，不拿一次奖学金不改名，我也想要甜甜的恋爱等等等等。这里我就不谈两面的观点了，我就简单提一提吧，常说拿奖学金我拿到了，挂科我也挂过一次，59分你体会过嘛？感情经历如果算拥有过的话有三次，不算的话那就是四次，当然，现在也没有拥有了，或许是缘分未到吧，正如一句话说：<font color=chocolate>“你的生命中有没有过这样一个人，或许已经从你的生活圈淡去，但却在你的点点滴滴留下余味…”</font> 错过了或许不会再来，但是能让你成长，后续我就不多细说了，欢迎读者交流</p><h3 id="将来的我"><a href="#将来的我" class="headerlink" title="将来的我"></a>将来的我</h3><hr/><p>关于这个，其实是说不好的，人生路漫漫，谁也想不到会有啥变化，我大学老师也和我们讲过，现在的一些想法其实也并不是特别成熟，并不会决定你的一生。老师当初也没有想到自己会去教一门原本不喜欢的课程，更没想过自己会当上一名老师，一名园丁。</p><p>但是，我就提及一下自己的想法把，写给未来的自己的。我主攻前端开发嘛，我喜欢探索知识，每做一门成绩出来，我就特别有成就感。而且通过写了这么两年博客，我对教育方面也是感受颇深，犹记得今年的职业规划班会上，关于兴趣岛那个小游戏，我选择了S岛，因为看重了教育方面，素质应该是比较高的，我喜欢<code>活在当下</code>的感觉。另外，对于我们程序员来说，其实干到30多岁就已经算是老程序员了，现在互联网发展迅速，知识也是变化特别快，可能今天学的，明天就过时了，到了不得不服老的年龄时，也许就是离开职场的时候了吧。</p><p>我也看了许多关于裁员的文章，其中提及到的就是关于程序员的副业，我想着会宣传教育，比如去b站当一个up主，分享自己的技术，去教育一批人，也算是有一定的影响力。</p><p>差不多就是往自媒体方面，又或者说去当讲师，去培训机构等等，反正是与教育相关。因为我觉得当程序员，尤其是往研发这一条不归路走的人，在语言方面会有一定弱化，每天都是与代码沟通，与人打交道机会可能没那么多，老师说过真正能干大事的还是学会与人打交道。所以呢，我尽管喜欢探索计算机领域，但是我更想让自己综合一点能力。</p><p>其实说白了，就是每天开心就好，做着自己想做的事情，乐此不疲，不再因为一些事情给自己压力，让自己过多的焦虑。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><hr><p>还是整一个心灵鸡汤：</p><p>与其热闹的引人夺目，<br>步步紧逼，<br>不如逐步做一个人群之中真实沉静的人，<br>不张扬，不虚饰，<br>随时保持后退的位，<br>心有所定，<br>淡泊安静，<br>专注做事</p><p>最后，这篇总结到此就结束啦，可能会有写的不是很好的地方，欢迎指正，这里是超逸の博客，不是只会写业务代码的前端开发工程师！</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200313140728784.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HNUCM Contest1088 - 2020年春季ACM集训队热身赛-第3场</title>
      <link href="/posts/19766/"/>
      <url>/posts/19766/</url>
      
        <content type="html"><![CDATA[<h2 id="Contest1092-2020年春季ACM集训队热身赛-第3场"><a href="#Contest1092-2020年春季ACM集训队热身赛-第3场" class="headerlink" title="Contest1092 - 2020年春季ACM集训队热身赛-第3场"></a>Contest1092 - 2020年春季ACM集训队热身赛-第3场</h2><p><strong><font color=chocolate>比赛原地址：</font></strong> <a href="http://acm.hnucm.edu.cn/JudgeOnline/contest.php?cid=1092" target="_blank" rel="noopener">传送门</a></p><hr/><p><strong><font color=red>推荐阅读：</font></strong> <a href="https://chocolate.blog.csdn.net/article/details/105264747" target="_blank" rel="noopener">【白嫖党】如何把前端学好？看完这篇，直呼：太强了！（历经半个月之作）</a></p><h2 id="问题-A-数字分类"><a href="#问题-A-数字分类" class="headerlink" title="问题 A: 数字分类"></a>问题 A: 数字分类</h2><p><strong>题目描述</strong></p><p>给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：<br>A1 = 能被5整除的数字中所有偶数的和；<br>A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…；<br>A3 = 被5除后余2的数字的个数；<br>A4 = 被5除后余3的数字的平均数，精确到小数点后1位；<br>A5 = 被5除后余4的数字中最大数字。</p><p><strong>输入</strong></p><p>每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过10000的待分类的正整数。数字间以空格分隔。</p><p><strong>输出</strong></p><p>对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。<br>若其中某一类数字不存在，则在相应位置输出“N”。</p><p><strong>样例输入</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">13</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">20</span> <span class="number">16</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><p><strong>样例输出</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">11</span> <span class="number">2</span> <span class="number">9.7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>没用到什么特殊的方法，注意一些细节就好了，具体看如下代码好了</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define mst(a,b) memset(a,v,sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int n,x;</span><br><span class="line">int a[<span class="number">10</span>];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int k=<span class="number">1</span>,cc=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">5</span>==<span class="number">0</span>&amp;&amp;x%<span class="number">2</span>==<span class="number">0</span>) a[<span class="number">1</span>]+=x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x%<span class="number">5</span>==<span class="number">1</span>)  a[<span class="number">2</span>]+=k*x,k=-k;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x%<span class="number">5</span>==<span class="number">2</span>) a[<span class="number">3</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x%<span class="number">5</span>==<span class="number">3</span>) a[<span class="number">4</span>]+=x,++cc;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x%<span class="number">5</span>==<span class="number">4</span>) a[<span class="number">5</span>]=max(a[<span class="number">5</span>],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a[i]) cout&lt;&lt;<span class="string">"N "</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!a[<span class="number">4</span>]) cout&lt;&lt;<span class="string">"N "</span>;</span><br><span class="line">        <span class="keyword">else</span> printf(<span class="string">"%.1f "</span>,a[<span class="number">4</span>]*<span class="number">1.0</span>/cc);</span><br><span class="line">    <span class="keyword">if</span>(!a[<span class="number">5</span>]) cout&lt;&lt;<span class="string">"N"</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;a[<span class="number">5</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-B-福尔摩斯的约会"><a href="#问题-B-福尔摩斯的约会" class="headerlink" title="问题 B: 福尔摩斯的约会"></a>问题 B: 福尔摩斯的约会</h2><p><strong>题目描述</strong></p><p>大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对位置相同的大写英文字母是第4个字母’D’，代表星期四（大写字符A到G表示星期一到星期日）；第2对位置相同的大写字母(A-N)或数字(0-9)表示HH，这里相同的字母是’E’，是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’(区分大小写)同时出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。<br>输入<br>输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。<br>输出<br>在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期<br>四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。</p><p><strong>样例输入</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3485</span>djDkxh4hhGE</span><br><span class="line"><span class="number">2984</span>akDfkkkkggEdsb</span><br><span class="line">s&amp;hgsfdk</span><br><span class="line">d&amp;Hyscvnm</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">THU <span class="number">14</span>:<span class="number">04</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>总共有4个字符串，前两个用来判断是星期几和小时，后两个是用来判断分钟</p><p>每次都只取第一个相等，即如果达到了符合条件的相等，就不用判断后面是否相等了</p><p>然后需要注意题目条件，我一开始条件搞错了，就…</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200405172409432.png"  alt=""></p><h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define mst(a,b) memset(a,v,sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line">char s1[maxn],s2[maxn];</span><br><span class="line">char day[<span class="number">7</span>][maxn]=&#123;<span class="string">"MON"</span>,<span class="string">"TUE"</span>,<span class="string">"WED"</span>,<span class="string">"THU"</span>,<span class="string">"FRI"</span>,<span class="string">"SAT"</span>,<span class="string">"SUN"</span>&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">    int dd=<span class="number">0</span>,idx=<span class="number">0</span>,hh=<span class="number">0</span>,mm=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;s1[i]&amp;&amp;s2[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]==s2[i]&amp;&amp;s1[i]&gt;=<span class="string">'A'</span>&amp;&amp;s1[i]&lt;=<span class="string">'G'</span>)&#123;</span><br><span class="line">            dd=s1[i]-<span class="string">'A'</span>;</span><br><span class="line">            idx=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=idx+<span class="number">1</span>;s1[i]&amp;&amp;s2[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]==s2[i]&amp;&amp;s1[i]&gt;=<span class="string">'0'</span>&amp;&amp;s1[i]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            hh=s1[i]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s1[i]==s2[i]&amp;&amp;s1[i]&gt;=<span class="string">'A'</span>&amp;&amp;s1[i]&lt;=<span class="string">'N'</span>)&#123;</span><br><span class="line">            hh=s1[i]-<span class="string">'A'</span>+<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;s1[i]&amp;&amp;s2[i];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]==s2[i]&amp;&amp;((s1[i]&gt;=<span class="string">'a'</span>&amp;&amp;s1[i]&lt;=<span class="string">'z'</span>)||(s1[i]&gt;=<span class="string">'A'</span>&amp;&amp;s1[i]&lt;=<span class="string">'Z'</span>)))&#123;</span><br><span class="line">           mm=i;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;day[dd]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    printf(<span class="string">"%02d:"</span>,hh);</span><br><span class="line">    printf(<span class="string">"%02d\n"</span>,mm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-C-德才论"><a href="#问题-C-德才论" class="headerlink" title="问题 C: 德才论"></a>问题 C: 德才论</h2><p><strong>题目描述</strong></p><p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之<br>小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”</p><p>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p><p><strong>输入</strong></p><p>输入第1行给出3个正整数，分别为：N（&lt;=10^5），即考生总数；L（&gt;=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格<br>被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到<br>但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼<br>亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。</p><p>随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。</p><p><strong>输出</strong></p><p>输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p><p><strong>样例输入</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span> <span class="number">60</span> <span class="number">80</span></span><br><span class="line"><span class="number">10000001</span> <span class="number">64</span> <span class="number">90</span></span><br><span class="line"><span class="number">10000002</span> <span class="number">90</span> <span class="number">60</span></span><br><span class="line"><span class="number">10000011</span> <span class="number">85</span> <span class="number">80</span></span><br><span class="line"><span class="number">10000003</span> <span class="number">85</span> <span class="number">80</span></span><br><span class="line"><span class="number">10000004</span> <span class="number">80</span> <span class="number">85</span></span><br><span class="line"><span class="number">10000005</span> <span class="number">82</span> <span class="number">77</span></span><br><span class="line"><span class="number">10000006</span> <span class="number">83</span> <span class="number">76</span></span><br><span class="line"><span class="number">10000007</span> <span class="number">90</span> <span class="number">78</span></span><br><span class="line"><span class="number">10000008</span> <span class="number">75</span> <span class="number">79</span></span><br><span class="line"><span class="number">10000009</span> <span class="number">59</span> <span class="number">90</span></span><br><span class="line"><span class="number">10000010</span> <span class="number">88</span> <span class="number">45</span></span><br><span class="line"><span class="number">10000012</span> <span class="number">80</span> <span class="number">100</span></span><br><span class="line"><span class="number">10000013</span> <span class="number">90</span> <span class="number">99</span></span><br><span class="line"><span class="number">10000014</span> <span class="number">66</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><p><strong>样例输出</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">10000013</span> <span class="number">90</span> <span class="number">99</span></span><br><span class="line"><span class="number">10000012</span> <span class="number">80</span> <span class="number">100</span></span><br><span class="line"><span class="number">10000003</span> <span class="number">85</span> <span class="number">80</span></span><br><span class="line"><span class="number">10000011</span> <span class="number">85</span> <span class="number">80</span></span><br><span class="line"><span class="number">10000004</span> <span class="number">80</span> <span class="number">85</span></span><br><span class="line"><span class="number">10000007</span> <span class="number">90</span> <span class="number">78</span></span><br><span class="line"><span class="number">10000006</span> <span class="number">83</span> <span class="number">76</span></span><br><span class="line"><span class="number">10000005</span> <span class="number">82</span> <span class="number">77</span></span><br><span class="line"><span class="number">10000002</span> <span class="number">90</span> <span class="number">60</span></span><br><span class="line"><span class="number">10000014</span> <span class="number">66</span> <span class="number">60</span></span><br><span class="line"><span class="number">10000008</span> <span class="number">75</span> <span class="number">79</span></span><br><span class="line"><span class="number">10000001</span> <span class="number">64</span> <span class="number">90</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题，比赛时没时间做了…</p><p>交了几发，wa了，但样例没问题，于是就找问题，结果出乎意料吧<br>改了两个地方就过了…</p><p><strong>原来版本：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stu[cnt].str=s,stu[cnt].dd=d,stu[cnt].cc=c,stu[cnt].sum=d+c;</span><br></pre></td></tr></table></figure><p><strong>现在版本：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">strcpy(stu[cnt].str,s),stu[cnt].dd=d,stu[cnt].cc=c,stu[cnt].sum=d+c;</span><br></pre></td></tr></table></figure><p><strong>原来版本：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bool cmp(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.w!=y.w) <span class="keyword">return</span> x.w&gt;y.w;</span><br><span class="line">    <span class="keyword">if</span>(x.sum!=y.sum) <span class="keyword">return</span> x.sum&gt;y.sum;</span><br><span class="line">    <span class="keyword">if</span>(x.dd!=y.dd) <span class="keyword">return</span> x.dd&gt;y.dd;</span><br><span class="line">    <span class="keyword">return</span> x.str&lt;y.str&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>现在版本：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bool cmp(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.w!=y.w) <span class="keyword">return</span> x.w&gt;y.w;</span><br><span class="line">    <span class="keyword">if</span>(x.sum!=y.sum) <span class="keyword">return</span> x.sum&gt;y.sum;</span><br><span class="line">    <span class="keyword">if</span>(x.dd!=y.dd) <span class="keyword">return</span> x.dd&gt;y.dd;</span><br><span class="line">    <span class="keyword">return</span> strcmp(x.str,y.str)&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完之后，我：？？？下次记得调用函数吧。。。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200405172923131.jpg#pic_center"  alt=""><br>好了，说一下解题思路：</p><p>下面这段代码，肯定不是一下子就写出这么整齐的，结构体里面原本就三个变量的，后续根据所需才慢慢加的。</p><p>此题很关键的就在于如何把结构体按照已知条件进行排序，而且题目还分了批次。</p><p>这里不妨将几类人根据权值排序，即下面代码中的<code>w</code> 。</p><ul><li>第一类考生——圣人（德才兼备） 定义权值 100</li><li>第二类考生——德达到优先录取，而才没达到，君子（德胜才） 定义权值  90</li><li>第三类考生——德才分均低于H，但是德分不低于才分  定义权值 80</li><li>第四类考生——达到最低线L 定义权值 70</li></ul><p><strong>如何排序？</strong></p><ul><li>首先，根据权值排序</li><li>然后，根据总分排序</li><li>总分相同，根据德分降序排序</li><li>德分相同，按准考证号的升序</li></ul><h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define mst(a,b) memset(a,v,sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">struct node&#123;</span><br><span class="line">    char str[<span class="number">20</span>];</span><br><span class="line">    int dd,cc;</span><br><span class="line">    int w;</span><br><span class="line">    int sum;</span><br><span class="line">&#125;stu[maxn];</span><br><span class="line">int n,ls,hs,d,c;</span><br><span class="line">char s[<span class="number">20</span>];</span><br><span class="line">bool cmp(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.w!=y.w) <span class="keyword">return</span> x.w&gt;y.w;</span><br><span class="line">    <span class="keyword">if</span>(x.sum!=y.sum) <span class="keyword">return</span> x.sum&gt;y.sum;</span><br><span class="line">    <span class="keyword">if</span>(x.dd!=y.dd) <span class="keyword">return</span> x.dd&gt;y.dd;</span><br><span class="line">    <span class="keyword">return</span> strcmp(x.str,y.str)&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;ls&gt;&gt;hs;</span><br><span class="line">    int cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;d&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=ls&amp;&amp;c&gt;=ls)&#123;</span><br><span class="line">            strcpy(stu[cnt].str,s),stu[cnt].dd=d,stu[cnt].cc=c,stu[cnt].sum=d+c;</span><br><span class="line">            <span class="keyword">if</span>(d&gt;=hs&amp;&amp;c&gt;=hs) stu[cnt].w=<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d&gt;=hs&amp;&amp;c&lt;hs) stu[cnt].w=<span class="number">90</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(d&lt;hs&amp;&amp;c&lt;hs&amp;&amp;d&gt;=c) stu[cnt].w=<span class="number">80</span>;</span><br><span class="line">            <span class="keyword">else</span> stu[cnt].w=<span class="number">70</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(stu,stu+cnt,cmp);</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">        cout&lt;&lt;stu[i].str&lt;&lt;<span class="string">" "</span>&lt;&lt;stu[i].dd&lt;&lt;<span class="string">" "</span>&lt;&lt;stu[i].cc&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-D-锤子剪刀布"><a href="#问题-D-锤子剪刀布" class="headerlink" title="问题 D: 锤子剪刀布"></a>问题 D: 锤子剪刀布</h2><p><strong>题目描述</strong></p><p>大家应该都会玩“锤子剪刀布”的游戏：<br>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p><p><strong>输入</strong></p><p>输入第1行给出正整数N（&lt;=10^5），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。</p><p><strong>输出</strong></p><p>输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。</p><p><strong>样例输入</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line">C J</span><br><span class="line">J B</span><br><span class="line">C B</span><br><span class="line">B B</span><br><span class="line">B C</span><br><span class="line">C C</span><br><span class="line">C B</span><br><span class="line">J B</span><br><span class="line">B C</span><br><span class="line">J J</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">B B</span><br></pre></td></tr></table></figure><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>如下述代码所示，这道题写的有点糊了，一开始各种 if 暴力判断，写着写着输出不太对劲，b一直没有赢过？</p><p>卡了一段时间后，想着整合起来，然后输出处理了一下。</p><h3 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define mst(a,b) memset(a,v,sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int n,x;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int s=<span class="number">0</span>,f=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">    int ac=<span class="number">0</span>,aj=<span class="number">0</span>,ab=<span class="number">0</span>,bc=<span class="number">0</span>,bj=<span class="number">0</span>,bb=<span class="number">0</span>;</span><br><span class="line">    char a[<span class="number">2</span>],b[<span class="number">2</span>];</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>((a[<span class="number">0</span>]==<span class="string">'C'</span>&amp;&amp;b[<span class="number">0</span>]==<span class="string">'J'</span>)||(a[<span class="number">0</span>]==<span class="string">'J'</span>&amp;&amp;b[<span class="number">0</span>]==<span class="string">'B'</span>)||(a[<span class="number">0</span>]==<span class="string">'B'</span>&amp;&amp;b[<span class="number">0</span>]==<span class="string">'C'</span>))&#123;</span><br><span class="line">            s++;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'C'</span>)ac++;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'B'</span>)ab++;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'J'</span>)aj++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((a[<span class="number">0</span>]==<span class="string">'C'</span>&amp;&amp;b[<span class="number">0</span>]==<span class="string">'C'</span>)||(a[<span class="number">0</span>]==<span class="string">'J'</span>&amp;&amp;b[<span class="number">0</span>]==<span class="string">'J'</span>)||(a[<span class="number">0</span>]==<span class="string">'B'</span>&amp;&amp;b[<span class="number">0</span>]==<span class="string">'B'</span>))&#123;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            f++;</span><br><span class="line">            <span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="string">'C'</span>)bc++;</span><br><span class="line">            <span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="string">'B'</span>)bb++;</span><br><span class="line">            <span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="string">'J'</span>)bj++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;<span class="string">" "</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;f&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;f&lt;&lt;<span class="string">" "</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="comment">/*if(aj&gt;ac&amp;&amp;aj&gt;ab) cout&lt;&lt;"J ";</span></span><br><span class="line"><span class="comment">    else if(ab&gt;ac&amp;&amp;ab&gt;aj) cout&lt;&lt;"B ";</span></span><br><span class="line"><span class="comment">    else cout&lt;&lt;"C ";</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    if(bj&gt;bc&amp;&amp;bj&gt;bb) cout&lt;&lt;"J ";</span></span><br><span class="line"><span class="comment">    else if(bb&gt;bc&amp;&amp;bb&gt;bj) cout&lt;&lt;"B ";</span></span><br><span class="line"><span class="comment">    else cout&lt;&lt;"C ";*/</span></span><br><span class="line">    cout&lt;&lt;((ac&gt;ab&amp;&amp;ac&gt;=aj)?<span class="string">'C'</span>:(ab&gt;=aj?<span class="string">'B'</span>:<span class="string">'J'</span>))&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    cout&lt;&lt;((bc&gt;bb&amp;&amp;bc&gt;=bj)?<span class="string">'C'</span>:(bb&gt;=bj?<span class="string">'B'</span>:<span class="string">'J'</span>))&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-E-月饼"><a href="#问题-E-月饼" class="headerlink" title="问题 E: 月饼"></a>问题 E: 月饼</h2><p><strong>题目描述</strong></p><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有3种月饼，其库存量分别为18、15、10万吨，总售价分别为75、72、45亿元。如果市场的最大需求量只有20万吨，那么我们最大收益策略应该是卖出全部15万吨第2种月饼、以及5万吨第3种月饼，获得 72 + 45/2 = 94.5（亿元）。</p><p><strong>输入</strong></p><p>每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N表示月饼的种类数、以及不超过500（以万吨为单位）的正整数D表示市场最大需求量。随后一行给出N个正实数表示每种月饼的库存量（以万吨为单位）；最后一行给出N个正实数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p><p><strong>输出</strong></p><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后2位。</p><p><strong>样例输入</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">20</span></span><br><span class="line"><span class="number">18</span> <span class="number">15</span> <span class="number">10</span></span><br><span class="line"><span class="number">75</span> <span class="number">72</span> <span class="number">45</span></span><br></pre></td></tr></table></figure><p><strong>样例输出</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">94.50</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题再熟悉不过了，当年PAT正式比赛前的一场全国模拟赛就是出的这一道，没啥说的，裸裸の贪心</p><h3 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">struct node&#123;</span><br><span class="line">    double w,v,bt;</span><br><span class="line">&#125;stu[maxn];</span><br><span class="line">int n;</span><br><span class="line">double sum;</span><br><span class="line">bool cmp(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.bt&gt;y.bt;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    <span class="keyword">while</span>(~scanf(<span class="string">"%d %lf"</span>,&amp;n,&amp;sum))&#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) scanf(<span class="string">"%lf"</span>,&amp;stu[i].w);</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(<span class="string">"%lf"</span>,&amp;stu[i].v);</span><br><span class="line">            stu[i].bt=(double)stu[i].v/stu[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(stu,stu+n,cmp);</span><br><span class="line">        double ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stu[i].w&gt;=sum)&#123;</span><br><span class="line">                ans+=(double)stu[i].bt*sum;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans+=stu[i].v;</span><br><span class="line">                sum-=stu[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(<span class="string">"%.2f\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-F-打印沙漏"><a href="#问题-F-打印沙漏" class="headerlink" title="问题 F: 打印沙漏"></a>问题 F: 打印沙漏</h2><p><strong>题目描述</strong></p><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p> 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递<br> 增；首尾符号数相等。</p><p> 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p><p><strong>输入</strong></p><p>输入在一行给出1个正整数N（N&lt;=1e5）和一个符号，中间以空格分隔。</p><p><strong>输出</strong></p><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p><p><strong>样例输入</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span> *</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>打印沙漏问题，PAT原题。</p><p>注意一个公式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">需要字符总数=<span class="number">2</span>*h*h<span class="number">-1</span>（其中h表示沙漏“一半”的形状）</span><br></pre></td></tr></table></figure><h3 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define mst(a,b) memset(a,v,sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int n,h;</span><br><span class="line">char s[<span class="number">5</span>];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    h=sqrt((n+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=h;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=h-i;j++) cout&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*i<span class="number">-1</span>;j++) cout&lt;&lt;s[<span class="number">0</span>];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=h;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=h-i;j++) cout&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*i<span class="number">-1</span>;j++) cout&lt;&lt;s[<span class="number">0</span>];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     ll ans=n-(<span class="number">2</span>*h*h<span class="number">-1</span>);</span><br><span class="line">     cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-G-组个最小数"><a href="#问题-G-组个最小数" class="headerlink" title="问题 G: 组个最小数"></a>问题 G: 组个最小数</h2><p><strong>题目描述</strong></p><p>给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：<br>给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。<br>现给定数字，请编写程序输出能够组成的最小的数。</p><p><strong>输入</strong></p><p>每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。<br>10个数字的总个数不超过200，且至少拥有1个非0的数字。</p><p><strong>输出</strong></p><p>在一行中输出能够组成的最小的数。</p><p><strong>样例输入</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>样例输出</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10015558</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>按照题意来说，只要0不打头，其它按顺序输出即可</p><h3 id="AC代码-6"><a href="#AC代码-6" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define mst(a,b) memset(a,v,sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">map&lt;int,int&gt; mp;</span><br><span class="line">int main()&#123;</span><br><span class="line">    mp.clear();</span><br><span class="line">    int x;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        mp[i]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i])&#123;</span><br><span class="line">                cout&lt;&lt;i;</span><br><span class="line">                mp[i]--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(mp[i])&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">            mp[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-H-跟奥巴马一起编程"><a href="#问题-H-跟奥巴马一起编程" class="headerlink" title="问题 H: 跟奥巴马一起编程"></a>问题 H: 跟奥巴马一起编程</h2><p><strong>题目描述</strong></p><p>美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。<br>2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！</p><p><strong>输入</strong></p><p>多组输入，每组数据一行，每行给出正方形边长N（3&lt;=N&lt;=20）和组成正方形边的某种字符C，间隔一个空格。</p><p><strong>输出</strong></p><p>输出由给定字符C画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。<br>每组数据后空一行</p><p><strong>样例输入</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> a</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aaaaaaaaaa</span><br><span class="line">a        a</span><br><span class="line">a        a</span><br><span class="line">a        a</span><br><span class="line">aaaaaaaaaa</span><br></pre></td></tr></table></figure><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>模拟即可</p><h3 id="AC代码-7"><a href="#AC代码-7" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int n;</span><br><span class="line">char s[<span class="number">10</span>];</span><br><span class="line">int main()&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;s)&#123;</span><br><span class="line">    int m=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||i==m<span class="number">-1</span>||j==<span class="number">0</span>||j==n<span class="number">-1</span>) cout&lt;&lt;s[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><blockquote><div>Github上面可以直接查看所有前端知识点梳理，<a href="https://github.com/Chocolate1999/Front-end-learning-to-organize-notes" target="_blank" rel="noopener">github传送门</a>，觉得不错，点个Star★，好运连连，Offer终究鼠于你，持续更新中。另外，也可以关注微信公众号：<font color=chocolate>小狮子前端Vue</font>，源码以及资料今后都会放在里面。</div></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> ACM </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HNUCM Contest1088 - 2020年春季ACM集训队热身赛-第2场</title>
      <link href="/posts/48363/"/>
      <url>/posts/48363/</url>
      
        <content type="html"><![CDATA[<h2 id="Contest1088-2020年春季ACM集训队热身赛-第2场"><a href="#Contest1088-2020年春季ACM集训队热身赛-第2场" class="headerlink" title="Contest1088 - 2020年春季ACM集训队热身赛-第2场"></a>Contest1088 - 2020年春季ACM集训队热身赛-第2场</h2><p><strong><font color=chocolate>比赛原地址：</font></strong> <a href="http://acm.hnucm.edu.cn/JudgeOnline/contest.php?cid=1088" target="_blank" rel="noopener">传送门</a></p><h2 id="问题-A-河畔军训"><a href="#问题-A-河畔军训" class="headerlink" title="问题 A: 河畔军训"></a>问题 A: 河畔军训</h2><p><strong>题目描述</strong></p><p>河畔镇是一个景色秀丽，气候宜人的度假胜地，每天都会有很多的游客来这里游玩。但奇怪的是这里总会出现一些潜伏者。果不其然，通过保卫者的跟踪，发现在河畔镇的地下隐藏着Blitz的秘密武器实验室。最危险的地方也是最安全的地方，这里人多，所以只能采用狙击作战，一场“无声无息“的战斗即刻打响。<br>每到周末小z，小y便开始在河畔军训小h(当然有时也会被反军训)。<br>不过他们军训采用刀战(即相遇时才可军训)<br>每当小z，小y，小h三人在河畔整相遇时，小z和小y便可军训小h<br>由于小h有兔耳朵buff加成，小h每秒最多可以移动3步，且可以选择上/下/左/右/左上/左下/右上/右下8个方向移动<br>小z，小y每秒均只能移动1步，只能上/下/左/右4个方向移动。<br>当然，三人均可选择保持原地不动。<br>三人移动始终在地图范围内。<br>下面，给你河畔的地图以及小z，小y，小h的初始坐标。<br>请你求出最快军训小h的时间(即3人相遇的最短时间)，如果无法军训小h则输出“lack of junxun”</p><p><strong>输入</strong></p><p>多组数据<br>每组数据第一行两个整数N,M(1&lt;=N,M&lt;=1000)代表河畔地图的行和列<br>接下来是N*M大小的地图<br>其中“z”，“y”，“h”分别代表小z，小y，小h的初始坐标<br>“#”代表障碍物，“.”表示可以正常通过的位置</p><p><strong>输出</strong></p><p>对于每组数据<br>如果能军训小h，则输出最快军训小h所需的时间<br>否则，输出“lack of junxun”</p><p><strong>样例输入</strong> </p><p>2 4<br>z..h<br>#y#.<br>2 3<br>z#y<br>#h.</p><p><strong>样例输出</strong><br>1<br>lack of junxun</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>分别从三个起点开始用BFS，考虑题目的特殊性：</p><ul><li>z和y不能走斜线，只有小h能走</li><li>小h每秒最多可以移动3步</li><li>输出最快军训小h所需的时间，那么就贪心一下，让小h每次都走最多步数：3步</li></ul><p>参考博文：<a href="https://blog.csdn.net/qq_43984169/article/details/105184977" target="_blank" rel="noopener">传送门</a></p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define mst(a,b) memset(a,b,sizeof(a))</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int n,m;</span><br><span class="line">int vis[<span class="number">3</span>][maxn][maxn];</span><br><span class="line">char mp[maxn][maxn];</span><br><span class="line">int dir[<span class="number">8</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">bool check(int x,int y,int id)&#123; <span class="comment">//check函数判断该点是否能走</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m&amp;&amp;mp[x][y]!=<span class="string">'#'</span>&amp;&amp;!vis[id][x][y]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;node&gt; Q[<span class="number">3</span>];</span><br><span class="line">bool bfs(int u)&#123;</span><br><span class="line">    int cnt=Q[u].size();</span><br><span class="line">    node now,nex;</span><br><span class="line">    <span class="keyword">while</span>(cnt--)&#123;</span><br><span class="line">        now=Q[u].front(),Q[u].pop();</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">4</span>&amp;&amp;(u==<span class="number">0</span>||u==<span class="number">1</span>)) <span class="keyword">break</span>;    <span class="comment">//z和y不能走斜线,只有h能走斜线</span></span><br><span class="line">            nex.x=now.x+dir[i][<span class="number">0</span>];</span><br><span class="line">            nex.y=now.y+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(check(nex.x,nex.y,u))&#123;</span><br><span class="line">                vis[u][nex.x][nex.y]=<span class="number">1</span>;</span><br><span class="line">                Q[u].push(nex);</span><br><span class="line">                <span class="keyword">if</span>(vis[<span class="number">0</span>][nex.x][nex.y]&amp;&amp;vis[<span class="number">1</span>][nex.x][nex.y]&amp;&amp;vis[<span class="number">2</span>][nex.x][nex.y])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">int solve()&#123;</span><br><span class="line">    int step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q[<span class="number">0</span>].empty()||!Q[<span class="number">1</span>].empty()||!Q[<span class="number">2</span>].empty())&#123;</span><br><span class="line">        ++step;</span><br><span class="line">        <span class="keyword">if</span>(bfs(<span class="number">0</span>)) <span class="keyword">return</span> step;</span><br><span class="line">        <span class="keyword">if</span>(bfs(<span class="number">1</span>)) <span class="keyword">return</span> step;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(bfs(<span class="number">2</span>)) <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        mst(vis,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!Q[<span class="number">0</span>].empty()) Q[<span class="number">0</span>].pop();</span><br><span class="line">        <span class="keyword">while</span>(!Q[<span class="number">1</span>].empty()) Q[<span class="number">1</span>].pop();</span><br><span class="line">        <span class="keyword">while</span>(!Q[<span class="number">2</span>].empty()) Q[<span class="number">2</span>].pop();</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;mp[i]+<span class="number">1</span>;</span><br><span class="line">        node now;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[i][j]==<span class="string">'z'</span>)&#123;</span><br><span class="line">                    now.x=i,now.y=j;</span><br><span class="line">                    vis[<span class="number">0</span>][i][j]=<span class="number">1</span>;</span><br><span class="line">                    Q[<span class="number">0</span>].push(now);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mp[i][j]==<span class="string">'y'</span>)&#123;</span><br><span class="line">                    now.x=i,now.y=j;</span><br><span class="line">                    vis[<span class="number">1</span>][i][j]=<span class="number">1</span>;</span><br><span class="line">                    Q[<span class="number">1</span>].push(now);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mp[i][j]==<span class="string">'h'</span>)&#123;</span><br><span class="line">                    now.x=i,now.y=j;</span><br><span class="line">                    vis[<span class="number">2</span>][i][j]=<span class="number">1</span>;</span><br><span class="line">                    Q[<span class="number">2</span>].push(now);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=solve();</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">"lack of junxun"</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-B-不高兴的津津"><a href="#问题-B-不高兴的津津" class="headerlink" title="问题 B: 不高兴的津津"></a>问题 B: 不高兴的津津</h2><p><strong>题目描述</strong></p><p>津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。</p><p><strong>输入</strong></p><p>输入包括七行数据，分别表示周一到周日的日程安排。每行包括两个小于10的非负整数，分别表示津津在学校上课的时间和妈妈安排她上课的时间。</p><p><strong>输出</strong></p><p>输出包括一行，这一行只包含一个数字。如果不会不高兴那么输出0，如果会那么输出最不高兴的是周几〔用1,2,3,4,5,6,7分别表示周一，周二，周三，周四，周五，周六，周日〕。如果有两天或两天以上不高兴的程度相当，那么输出时间最靠前的一天。</p><p><strong>样例输入</strong><br>53<br>62<br>72<br>53<br>54<br>04<br>06</p><p><strong>样例输出</strong> </p><p>3</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>输出最不高兴的天数，注意输入的特殊性，中间没有空格，因此需要进行字符串处理，判断最大值时取大于号&gt;即可</p><h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">int n,m;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    int idx=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)&#123;</span><br><span class="line">        char s[<span class="number">5</span>];</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        n=s[<span class="number">0</span>]-<span class="string">'0'</span>;</span><br><span class="line">        m=s[<span class="number">1</span>]-<span class="string">'0'</span>;</span><br><span class="line">        int sum=n+m;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;<span class="number">8</span>&amp;&amp;sum&gt;tmp)&#123;</span><br><span class="line">            idx=i;</span><br><span class="line">            tmp=sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;idx&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-C-花生采摘"><a href="#问题-C-花生采摘" class="headerlink" title="问题 C: 花生采摘"></a>问题 C: 花生采摘</h2><p><strong>题目描述</strong></p><p>鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！——熊字”。<br>鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格〔如图1〕。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”<br>我们假定多多在每个单位时间内，可以做以下四件事情中的一件：<br>1)从路边跳到最靠近路边〔即第一行〕的某棵花生植株；<br>2)从一棵植株跳到前后左右与之相邻的另一棵植株；<br>3)采摘一棵植株下的花生；<br>4)从最靠近路边〔即第一行〕的某棵花生植株跳回路边。<br>现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。<br>例如在样例所示的花生田里，只有位于(2,5),(3,7),(4,2),(5,4)的植株下长有花生，个数分别为13,7,15,9。多多在21个单位时间内，最多可以采到37个花生。 </p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200329213020656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p><strong>输入</strong></p><p>输入的第一行包括三个整数，M,N和K，用空格隔开；表示花生田的大小为M*N〔1&lt;=M,N&lt;=20〕，多多采花生的限定时间为K〔0&lt;=K&lt;=1000〕个单位时间。接下来的M行，每行包括N个非负整数，也用空格隔开；第i+1行的第j个整数Pij〔0&lt;=Pij&lt;=500〕表示花生田里植株(i,j)下花生的数目，0表示该植株下没有花生。<br>输出<br>输出包括一行，这一行只包含一个整数，即在限定时间内，多多最多可以采到花生的个数。</p><p><strong>样例输入</strong> </p><p>6 7 21<br>0 0 0 0 0 0 0<br>0 0 0 0 13 0 0<br>0 0 0 0 0 0 7<br>0 15 0 0 0 0 0<br>0 0 0 9 0 0 0<br>0 0 0 0 0 0 0</p><p><strong>样例输出</strong> </p><p>37</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>贪心，在有限时间内获得最多的花生，注意点：</p><ul><li>起初和结束会花费1单位时间</li><li>猴子位移也会花费距离时间</li><li>采花生会花费1单位时间</li><li>当前花生能不能拿的条件是，判断一下能不能回到路边，不能回到路边当前就不能采了</li></ul><p>不过数据不是很强，勉强过了。严格一点的话可能会有数据会卡住。</p><h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define mst(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define p pair&lt;char,int&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">int n,m,k,x;</span><br><span class="line">vector&lt;int&gt; G[maxn];</span><br><span class="line"><span class="keyword">set</span>&lt;int&gt; st;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y,cc;</span><br><span class="line">&#125;stu[maxn];</span><br><span class="line">bool cmp(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.cc&gt;y.cc;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    int cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(x) stu[cnt].x=i,stu[cnt].y=j,stu[cnt++].cc=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(stu,stu+cnt,cmp);</span><br><span class="line">    int res=<span class="number">0</span>,ans=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    ans+=stu[<span class="number">0</span>].x;</span><br><span class="line">    k--;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;k)&#123;</span><br><span class="line">        ans+=<span class="number">2</span>;   <span class="comment">//起初到路边+采当前花生花费的时间</span></span><br><span class="line">        res+=stu[<span class="number">0</span>].cc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">        ans+=(abs(stu[i].x-stu[i<span class="number">-1</span>].x)+abs(stu[i].y-stu[i<span class="number">-1</span>].y));</span><br><span class="line">        <span class="keyword">if</span>(ans+stu[i].x&lt;k)&#123;</span><br><span class="line">            ans+=<span class="number">1</span>;</span><br><span class="line">            res+=stu[i].cc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-D-FBI树"><a href="#问题-D-FBI树" class="headerlink" title="问题 D: FBI树"></a>问题 D: FBI树</h2><p><strong>题目描述</strong></p><p>我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串那么称为F串。<br>FBI树是一种二叉树[1]，它的结点类型也包括F结点，B结点和I结点三种。由一个长度为2N的“01”串S可以构造出一棵FBI树T，递归的构造方法如下：<br>1)T的根结点为R，其类型与串S的类型相同；<br>2)假设串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。<br>现在给定一个长度为2N的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历序列[2]。</p><p><strong>输入</strong></p><p>第一行是一个整数N〔1&lt;=N&lt;=128〕，数据保证n为2的幂次方。<br>第二行是一个长度为2N的“01”串。</p><p><strong>输出</strong></p><p>输出包括一行，这一行只包含一个字符串，即FBI树的后序遍历序列。</p><p><strong>样例输入</strong> </p><p>4<br>10001011</p><p><strong>样例输出</strong> </p><p>IBFBBBFIBFIIIFF</p><p><strong>提示</strong></p><p>[1]二叉树：二叉树是结点的有限集合，这个集合或为空集，或由一个根结点和两棵不相交的二叉树组成。这两棵不相交的二叉树分别称为这个根结点的左子树和右子树。<br>[2]后序遍历：后序遍历是深度优先遍历二叉树的一种方法，它的递归定义是：先后序遍历左子树，再后序遍历右子树，最后访问根。 </p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200329213540368.png"  alt=""><br>非常经典的一道二叉树题。根据题意建树，会发现这就是先序遍历。而题目的输出是后序遍历，那么我们就可以考虑，递归先序遍历建树，回溯的过程输出，因为先序遍历回溯就是后序遍历。</p><h3 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define mst(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define p pair&lt;char,int&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">int n,m,cc;</span><br><span class="line">char str[maxn];</span><br><span class="line">int ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> output(int le,int re)&#123;</span><br><span class="line">    int k0=<span class="number">0</span>,k1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=le;i&lt;=re;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'0'</span>) k0++;</span><br><span class="line">        <span class="keyword">else</span> k1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k0&amp;&amp;k1) cout&lt;&lt;<span class="string">'F'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!k0&amp;&amp;k1) cout&lt;&lt;<span class="string">'I'</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">'B'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> fun(int l,int r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l!=r)&#123;</span><br><span class="line">        fun(l,(l+r)/<span class="number">2</span>);</span><br><span class="line">        fun((l+r)/<span class="number">2</span>+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    output(l,r);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    int len=strlen(str)<span class="number">-1</span>;</span><br><span class="line">    fun(<span class="number">0</span>,len);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-E-火星人"><a href="#问题-E-火星人" class="headerlink" title="问题 E: 火星人"></a>问题 E: 火星人</h2><p><strong>题目描述</strong></p><p>人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。<br>火星人用一种非常简单的方式来表示数字——掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为1，2，3……。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。<br>一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指——拇指、食指、中指、无名指和小指分别编号为1，2，3，4和5，当它们按正常顺序排列时，形成了5位数12345，当你交换无名指和小指的位置时，会形成5位数12354，当你把五个手指的顺序完全颠倒时，会形成54321，在所有能够形成的120个5位数中，12345最小，它表示1；12354第二小，它表示2；54321最大，它表示120。下表展示了只有3根手指时能够形成的6个3位数和它们代表的数字：<br>三进制数<br>123<br>132<br>213<br>231<br>312<br>321<br>代表的数字<br>1<br>2<br>3<br>4<br>5<br>6<br>现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。<br>输入<br>输入包括三行，第一行有一个正整数N，表示火星人手指的数目〔1&lt;=N&lt;=10000〕。第二行是一个正整数M，表示要加上去的小整数〔1&lt;=M&lt;=100〕。下一行是1到N这N个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。<br>输出<br>输出只有一行，这一行含有N个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。</p><p><strong>样例输入</strong> </p><p>5<br>3<br>1 2 3 4 5</p><p><strong>样例输出</strong> </p><p>1 2 4 5 3</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>文章挺长，但是讲来讲去，就是全排列问题，直接调用<code>next_permutation</code>即可</p><h3 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define p pair&lt;char,int&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">int n,m;</span><br><span class="line">stack&lt;p&gt; sk;</span><br><span class="line">char str[maxn];</span><br><span class="line">int a[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">while</span>(m--) next_permutation(a,a+n);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    cout&lt;&lt;a[n<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-F-小B旅游"><a href="#问题-F-小B旅游" class="headerlink" title="问题 F: 小B旅游"></a>问题 F: 小B旅游</h2><p><strong>题目描述</strong></p><p>小B在一个有N个城市M条道路的国家，每条道路连接的城市可以互相到达且每条道路小B都要花1步去走过它。现在他在1号城市，问他走P步最多能走多少个不同的城市？ </p><p><strong>输入</strong></p><p>输入格式：第1行，三个正整数N、M、P，意义如题：接下来M行，每行两个整数U、V，表示存在一条连接U、V的无向边。<br>输出<br>输出格式：1行，一个整数，表示从1号城市出发走P步的所有情况，共能经过多少个不同的城市。 </p><p><strong>样例输入</strong><br>4 4 2<br>1 2<br>1 3<br>2 3<br>3 4</p><p><strong>样例输出</strong><br>4</p><p><strong>提示</strong><br>数据规模：<br> 1&lt;=N&lt;=100000，1&lt;=M&lt;=5000000，1&lt;=P&lt;=10000</p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>搜索题，直接搜就是，但是开始做的时候是从1开始搜，总是</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200329214154462.png"  alt=""></p><p>不造被卡在哪了，后面换了一种方式，直接先加一步，从孩子结点开始搜，然后过了</p><h3 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define mst(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define p pair&lt;char,int&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">int n,m,cc;</span><br><span class="line">vector&lt;int&gt; G[maxn];</span><br><span class="line">int vis[maxn];</span><br><span class="line">int ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> dfs(int u,int cnt)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;cc) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">        ++ans;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(auto v:G[u])</span><br><span class="line">        <span class="keyword">if</span>(!vis[v]) dfs(v,cnt+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;cc;</span><br><span class="line">    int u,v;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(auto u:G[<span class="number">1</span>])</span><br><span class="line">        dfs(u,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-G-括号匹配"><a href="#问题-G-括号匹配" class="headerlink" title="问题 G: 括号匹配"></a>问题 G: 括号匹配</h2><p><strong>题目描述</strong></p><p>括号主要有：大括号“{ }”、中括号“[ ]”、小括号“( )”。给定一个只包含左右括号的合法括号序列(序列长度2&lt;=n&lt;=10000)，按右括号从左到右的顺序输出每一对配对的括号出现的位置（括号序列以0开始编号） </p><p><strong>输入</strong><br>输入格式：仅1行，表一个合法的括号序列 </p><p><strong>输出</strong><br>输出格式：设括号序列有n个右括号，每行两个整数l、r，表示配对的括号左括号出现在第l位，右括号出现在第r位。 </p><p><strong>样例输入</strong></p><p>{()[()()]}()</p><p><strong>样例输出</strong><br>1 2<br>4 5<br>6 7<br>3 8<br>0 9<br>10 11</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>括号匹配问题，经常性扯到使用栈的问题，根据题意，需要搞一个对子<code>pair</code>存一下下标，每次取出栈顶元素和当前准备放入的元素进行比较，如果括号匹配成功即弹出栈，输出下标即可</p><h3 id="AC代码-6"><a href="#AC代码-6" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define p pair&lt;char,int&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">int n,m;</span><br><span class="line">stack&lt;p&gt; sk;</span><br><span class="line">char str[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;strlen(str);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sk.empty())&#123;</span><br><span class="line">            p p1=make_pair(str[i],i);</span><br><span class="line">            sk.push(p1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">'&#125;'</span>)&#123;</span><br><span class="line">            p now=sk.top();</span><br><span class="line">            <span class="keyword">if</span>(now.first==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                cout&lt;&lt;now.second&lt;&lt;<span class="string">" "</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                sk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">']'</span>)&#123;</span><br><span class="line">            p now=sk.top();</span><br><span class="line">            <span class="keyword">if</span>(now.first==<span class="string">'['</span>)&#123;</span><br><span class="line">                cout&lt;&lt;now.second&lt;&lt;<span class="string">" "</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                sk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">            p now=sk.top();</span><br><span class="line">            <span class="keyword">if</span>(now.first==<span class="string">'('</span>)&#123;</span><br><span class="line">                cout&lt;&lt;now.second&lt;&lt;<span class="string">" "</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                sk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p p2=make_pair(str[i],i);</span><br><span class="line">            sk.push(p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-H-报数游戏"><a href="#问题-H-报数游戏" class="headerlink" title="问题 H: 报数游戏"></a>问题 H: 报数游戏</h2><p><strong>题目描述</strong></p><p>有n个小朋友，按顺时针方向围成一圈（编号从1—n），从第1号开始报数，一直数到m，数到m的小朋友退出圈外，剩下的小朋友再接着从1开始报数。</p><p><strong>输入</strong><br>T组数据，第一行为T(1&lt;=T&lt;=10)<br>接下来T行，每行用空格分开两个整数n、m（1&lt;=m，n&lt;=10000）</p><p><strong>输出</strong><br>输出T行<br>每行一个答案表示第1号小朋友退出前，报数为m的次数</p><p><strong>样例输入</strong><br>1<br>6 2</p><p><strong>样例输出</strong><br>4</p><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>报数游戏，与约瑟夫环问题有关，可以用递归求解，但是不太会做了，于是用了如下模拟，数据不强没卡住…</p><h3 id="AC代码-7"><a href="#AC代码-7" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define mst(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define p pair&lt;char,int&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">int n,m,cc,t;</span><br><span class="line">char str[maxn];</span><br><span class="line">int ans=<span class="number">0</span>;</span><br><span class="line">int a[maxn];</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">int vis[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        mst(vis,<span class="number">0</span>);</span><br><span class="line">        int cnt=<span class="number">0</span>,ans=<span class="number">-1</span>;</span><br><span class="line">        v.clear();</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) v.push_back(i);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            int len=v.size();</span><br><span class="line">            <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v[i]])</span><br><span class="line">                    ++cnt;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v[i]]&amp;&amp;cnt==m)&#123;</span><br><span class="line">                    vis[v[i]]=<span class="number">1</span>;</span><br><span class="line">                    ++ans,cnt=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(vis[<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(vis[<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-I-小A的烦恼"><a href="#问题-I-小A的烦恼" class="headerlink" title="问题 I: 小A的烦恼"></a>问题 I: 小A的烦恼</h2><p><strong>题目描述</strong></p><p>小A生活在一个神奇的国家，这个国家有N（N&lt;=100000）个城市，还有M（M&lt;=5000000）条道路连接两城市。道路连接的两个城市可以直接免费到达。小A比较烦恼，因为他想知道每个城市能直接到达哪些城市，你能帮帮他吗？保证每个城市都有道路与其连接。（注：按照输入的道路顺序输出每个城市直接连接的城市,若有城市出现多次，则按最小出现次序输出） </p><p><strong>输入</strong><br>第1行包含两个整数N和M；接下来M行，每行两个整数描述一条道路连接的两个城市的编号。</p><p><strong>输出</strong><br>输出N行，每行若干个用一个空格隔开的整数；第I行输出的是与城市I直接相连城市编号，保证城市的出现按照道路输入的先后顺序出现。 </p><p><strong>样例输入</strong><br>4 5<br>2 3<br>3 1<br>1 4<br>2 4<br>1 2</p><p><strong>样例输出</strong><br>3 4 2<br>3 4 1<br>2 1<br>1 2</p><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>由题意，直接建图输出每个城市的子结点即可，不过总感觉没这么简单吧，这个题还是卡了挺多人的…   可能还是数据不强吧…</p><h3 id="AC代码-8"><a href="#AC代码-8" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define mst(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define p pair&lt;char,int&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">int n,m;</span><br><span class="line">vector&lt;int&gt; G[maxn];</span><br><span class="line"><span class="keyword">set</span>&lt;int&gt; st;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(auto v:G[i])&#123;</span><br><span class="line">            cout&lt;&lt;v&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-J-一步之遥"><a href="#问题-J-一步之遥" class="headerlink" title="问题 J: 一步之遥"></a>问题 J: 一步之遥</h2><p><strong>题目描述</strong></p><p>小B在一个有N个城市M条道路的国家，每条道路连接的城市可以互相到达且每条道路都要花1步去走过它。现在他在P号城市，问有多少城市走1步能到达该城市？ </p><p><strong>输入</strong></p><p>多组输入<br>第1行，三个正整数N、M、P，意义如题。<br>接下来M行，每行两个整数U、V，表示存在一条连接U、V的无向边。（0&lt;=N&lt;=1000000,0&lt;=M&lt;=500000）</p><p><strong>输出</strong><br>1行，走1步能到P城市的城市数量。</p><p><strong>样例输入</strong><br>4 4 1<br>1 2<br>1 3<br>2 3<br>3 4</p><p><strong>样例输出</strong><br>2</p><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>问从p号城市，通过一步就能到达的城市数量。开始想着直接建图，然后输出p城市的子结点即可，然后用set直接去重一下，应该能过，不过一直卡在了33%</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020032921544874.png"  alt=""></p><p>后面也尝试了用vis数组判断一下，也wa了。</p><p>最后，考虑只用看p城市相连边的城市数目即可。直接用set不就好了嘛，下面代码不是最简代码，最简放后面</p><h3 id="AC代码-9"><a href="#AC代码-9" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define mst(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define endl '\n'</span><br><span class="line">#define p pair&lt;char,int&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">int n,m;</span><br><span class="line">vector&lt;int&gt; G[maxn];</span><br><span class="line"><span class="keyword">set</span>&lt;int&gt; st;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    int dd;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&gt;&gt;dd)&#123;</span><br><span class="line">        st.clear();</span><br><span class="line">        int cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            <span class="keyword">if</span>(u==dd)&#123;</span><br><span class="line">                vis[v]=<span class="number">1</span>;</span><br><span class="line">                ++cnt;</span><br><span class="line">                st.insert(v);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v==dd)&#123;</span><br><span class="line">                vis[u]=<span class="number">1</span>;</span><br><span class="line">                ++cnt;</span><br><span class="line">                st.insert(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for(auto x:G[dd])</span></span><br><span class="line"><span class="comment">            st.insert(x);</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;st.size()&lt;&lt;endl;*/</span></span><br><span class="line">        <span class="comment">//cnt=st.size();</span></span><br><span class="line">        cout&lt;&lt;st.size()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define endl '\n'</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line"><span class="keyword">set</span>&lt;int&gt; st;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin.tie(<span class="number">0</span>);</span><br><span class="line">    int dd;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&gt;&gt;dd)&#123;</span><br><span class="line">        st.clear();</span><br><span class="line">        int cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            <span class="keyword">if</span>(u==dd)</span><br><span class="line">                st.insert(v);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v==dd)</span><br><span class="line">                st.insert(u);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;st.size()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> ACM </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【再也不怕面试官要你手写排序算法】一文详细解读前后端之各种排序算法</title>
      <link href="/posts/61237/"/>
      <url>/posts/61237/</url>
      
        <content type="html"><![CDATA[<h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>1.依次比较相邻的两个数，如果第一个比第二个小，不变。如果第一个比第二个大，调换顺序。一轮下来，最后一个是最大的数</div><div>2.对除了最后一个之外的数重复第一步，直到只剩一个数</div></blockquote><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331111904150.png#pic_center"  alt=""></p><h3 id="算法实现（JS代码）"><a href="#算法实现（JS代码）" class="headerlink" title="算法实现（JS代码）"></a>算法实现（JS代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> len=arr.length;</span><br><span class="line">            <span class="keyword">var</span> i,j;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;j++)&#123;  </span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) <span class="comment">//两两之间进行比较</span></span><br><span class="line">                        swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> tmp=arr[i];</span><br><span class="line">            arr[i]=arr[j];</span><br><span class="line">            arr[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行结果1"><a href="#执行结果1" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331112633479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h3 id="算法实现（C-代码）"><a href="#算法实现（C-代码）" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;n-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">                swap(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2"><a href="#执行结果2" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331202505962.png"  alt=""></p><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>1.找出最小的数，和第一个交换位置</div><div>2.在剩下的数中，找出最二小的数，放在第二个</div><div>3.依次类推，排出顺序</div></blockquote><h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331113054561.png#pic_center"  alt=""></p><h3 id="算法实现（JS代码）-1"><a href="#算法实现（JS代码）-1" class="headerlink" title="算法实现（JS代码）"></a>算法实现（JS代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> len=arr.length;</span><br><span class="line">            <span class="keyword">var</span> i,j,xmin;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                xmin=i;   <span class="comment">//将当前值设为最小值</span></span><br><span class="line">                <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&lt;arr[xmin])</span><br><span class="line">                        xmin=j;  <span class="comment">//在后面找到更小的值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i!=xmin)</span><br><span class="line">                    swap(arr,i,xmin) <span class="comment">//将找到的更小值进行交换</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> tmp=arr[i];</span><br><span class="line">            arr[i]=arr[j];</span><br><span class="line">            arr[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行结果1-1"><a href="#执行结果1-1" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331114113439.png"  alt=""></p><h3 id="算法实现（C-代码）-1"><a href="#算法实现（C-代码）-1" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        int xmin=i;</span><br><span class="line">        <span class="keyword">for</span>(int j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[xmin]) xmin=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xmin!=i) swap(a[xmin],a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2-1"><a href="#执行结果2-1" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331202505962.png"  alt=""></p><h2 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h2><h3 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>1.把数组分为[已排序]和[未排序]两部分,第一个数为[已排序]，其余为[未排序]</div><div>2.从[未排序]抽出第一个数，和[已排序]部分比较，插入到合适的位置</div></blockquote><h3 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331115752579.png#pic_center"  alt=""></p><h3 id="算法实现（Js代码）"><a href="#算法实现（Js代码）" class="headerlink" title="算法实现（Js代码）"></a>算法实现（Js代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> len=arr.length;</span><br><span class="line">            <span class="keyword">var</span> i,j,val;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                val=arr[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&lt;val) <span class="keyword">break</span>; <span class="comment">//找到可以放的位置即跳出</span></span><br><span class="line">                    arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+<span class="number">1</span>]=val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行结果1-2"><a href="#执行结果1-2" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331114113439.png"  alt=""></p><h3 id="算法实现（C-代码）-2"><a href="#算法实现（C-代码）-2" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        int val=a[i],j;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;val) <span class="keyword">break</span>;</span><br><span class="line">            a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>]=val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2-2"><a href="#执行结果2-2" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331202505962.png"  alt=""></p><h2 id="4、归并排序-分而治之"><a href="#4、归并排序-分而治之" class="headerlink" title="4、归并排序(分而治之)"></a>4、归并排序(分而治之)</h2><h3 id="基本思路-3"><a href="#基本思路-3" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>1.不断将数组对半分，直到每个数组只有一个</div><div>2.将分出来的部分重新合并</div><div>3.合并的时候按顺序排列</div></blockquote><h3 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331131808651.png#pic_center"  alt=""></p><h3 id="算法实现（JS代码）-2"><a href="#算法实现（JS代码）-2" class="headerlink" title="算法实现（JS代码）"></a>算法实现（JS代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res=[],</span><br><span class="line">                i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//合并两个数组（按照从小到大的顺序）</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;left.length&amp;&amp;j&lt;right.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left[i]&lt;right[j])&#123;</span><br><span class="line">                    res.push(left[i++]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.push(right[j++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数组拼接</span></span><br><span class="line">            <span class="keyword">return</span> res.concat(left.slice(i)).concat(right.slice(j));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> len=arr.length;</span><br><span class="line">            <span class="keyword">var</span> i,j;</span><br><span class="line">            <span class="comment">//不断拆分至只有一个数</span></span><br><span class="line">            <span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">            <span class="keyword">var</span> mid=<span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">var</span> left=arr.slice(<span class="number">0</span>,mid),</span><br><span class="line">                right=arr.slice(mid);</span><br><span class="line">            <span class="keyword">return</span> merge(mergeSort(left),mergeSort(right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        arr=mergeSort(arr);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行结果1-3"><a href="#执行结果1-3" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331114113439.png"  alt=""></p><h3 id="算法实现（C-代码）-3"><a href="#算法实现（C-代码）-3" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line"><span class="keyword">void</span> mergeArray(int le,int mid,int re)&#123;</span><br><span class="line">    int len=re-le+<span class="number">1</span>;</span><br><span class="line">    int * tmp=<span class="keyword">new</span> int[len];</span><br><span class="line">    int cnt=<span class="number">0</span>;</span><br><span class="line">    int i=le,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=re)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j]) tmp[cnt++]=a[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[cnt++]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[cnt++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=re) tmp[cnt++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;len;j++) a[le+j]=tmp[j];</span><br><span class="line">    <span class="keyword">delete</span> [] tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> mergeSort(int le,int re)&#123;</span><br><span class="line">    <span class="keyword">if</span>(le&lt;re)&#123;</span><br><span class="line">        int mid=(le+re)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(le,mid);</span><br><span class="line">        mergeSort(mid+<span class="number">1</span>,re);</span><br><span class="line">        mergeArray(le,mid,re);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    mergeSort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2-3"><a href="#执行结果2-3" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331202505962.png"  alt=""></p><h2 id="5、快速排序"><a href="#5、快速排序" class="headerlink" title="5、快速排序"></a>5、快速排序</h2><h3 id="基本思路-4"><a href="#基本思路-4" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>1.以一个数为基准(中间的数)，比基准小的放到左边，比基准大的放到右边</div><div>2.再按此方法对这两部分数据分别进行快速排序（递归进行）</div><div>3.不能再分后退出递归，并重新将数组合并</div></blockquote><h3 id="图示-4"><a href="#图示-4" class="headerlink" title="图示"></a>图示</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331140023958.png#pic_center"  alt=""></p><h3 id="算法实现（JS代码）-3"><a href="#算法实现（JS代码）-3" class="headerlink" title="算法实现（JS代码）"></a>算法实现（JS代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr,p,q</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> i = p;</span><br><span class="line">            <span class="keyword">var</span> x= arr[p];</span><br><span class="line">            <span class="keyword">var</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=p+<span class="number">1</span>;j&lt;=q;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;=x)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                    swap(arr,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,p);</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">//返回划分中间位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,p,q</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p&lt;q)&#123;</span><br><span class="line">                <span class="keyword">var</span> k = partition(arr,p,q);  <span class="comment">//确定划分中间位置</span></span><br><span class="line">                quickSort(arr,p,k<span class="number">-1</span>);   <span class="comment">//对左边部分进行递归</span></span><br><span class="line">                quickSort(arr,k+<span class="number">1</span>,q);   <span class="comment">//对右边部分进行递归</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> tmp=arr[i];</span><br><span class="line">            arr[i]=arr[j];</span><br><span class="line">            arr[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行结果1-4"><a href="#执行结果1-4" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331114113439.png"  alt=""></p><h3 id="算法实现（C-代码）-4"><a href="#算法实现（C-代码）-4" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line">int quick_partition(int p,int q)&#123;</span><br><span class="line">    int i=p;</span><br><span class="line">    int x=a[p];</span><br><span class="line">    <span class="keyword">for</span>(int j=p+<span class="number">1</span>;j&lt;=q;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&lt;=x)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            swap(a[i],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a[i],a[p]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> quick_sort(int p,int q)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;q)&#123;</span><br><span class="line">        int k=quick_partition(p,q);</span><br><span class="line">        quick_sort(p,k<span class="number">-1</span>);</span><br><span class="line">        quick_sort(k+<span class="number">1</span>,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    quick_sort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2-4"><a href="#执行结果2-4" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331202505962.png"  alt=""></p><h2 id="6、随机化快速排序"><a href="#6、随机化快速排序" class="headerlink" title="6、随机化快速排序"></a>6、随机化快速排序</h2><h3 id="基本思路-5"><a href="#基本思路-5" class="headerlink" title="基本思路"></a>基本思路</h3><blockquote><div>随机化快速排序只是在快排基础上将主元通过随机函数选取一下了。</div></blockquote><p><strong>关于js中随机产生【n , m】随机数实例：</strong></p><p>在本例中，我们将取得介于 1 到 10 之间的一个随机数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random()*<span class="number">10</span>)+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><p>5</p><h3 id="算法实现（Js代码）-1"><a href="#算法实现（Js代码）-1" class="headerlink" title="算法实现（Js代码）"></a>算法实现（Js代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">//随机选取主元</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">randk</span>(<span class="params">arr,p,q</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> k = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*q+p);</span><br><span class="line">            swap(arr,p,k);</span><br><span class="line">            <span class="keyword">return</span> partition(arr,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr,p,q</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> i = p;</span><br><span class="line">            <span class="keyword">var</span> x= arr[p];</span><br><span class="line">            <span class="keyword">var</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=p+<span class="number">1</span>;j&lt;=q;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;=x)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                    swap(arr,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,p);</span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">//返回划分中间位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,p,q</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p&lt;q)&#123;</span><br><span class="line">                <span class="keyword">var</span> k = randk(arr,p,q);  <span class="comment">//确定划分中间位置</span></span><br><span class="line">                quickSort(arr,p,k<span class="number">-1</span>);   <span class="comment">//对左边部分进行递归</span></span><br><span class="line">                quickSort(arr,k+<span class="number">1</span>,q);   <span class="comment">//对右边部分进行递归</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr,i,j</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> tmp=arr[i];</span><br><span class="line">            arr[i]=arr[j];</span><br><span class="line">            arr[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行结果1-5"><a href="#执行结果1-5" class="headerlink" title="执行结果1"></a>执行结果1</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331114113439.png"  alt=""></p><h3 id="算法实现（C-代码）-5"><a href="#算法实现（C-代码）-5" class="headerlink" title="算法实现（C++代码）"></a>算法实现（C++代码）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int maxn=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line">int a[maxn],n;</span><br><span class="line">int quick_partition(int p,int q)&#123;</span><br><span class="line">    int i=p;</span><br><span class="line">    int x=a[p];</span><br><span class="line">    <span class="keyword">for</span>(int j=p+<span class="number">1</span>;j&lt;=q;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&lt;=x)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            swap(a[i],a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a[i],a[p]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">int rand(int p,int q)&#123;</span><br><span class="line">    int k=rand()%(q-p+<span class="number">1</span>)+p;</span><br><span class="line">    swap(a[k],a[p]);</span><br><span class="line">    <span class="keyword">return</span> quick_partition(p,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> qsort(int p,int q)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;q)&#123;</span><br><span class="line">        int k=rand(p,q);</span><br><span class="line">        qsort(p,k<span class="number">-1</span>);</span><br><span class="line">        qsort(k+<span class="number">1</span>,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    qsort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果2-5"><a href="#执行结果2-5" class="headerlink" title="执行结果2"></a>执行结果2</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200331202505962.png"  alt=""></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p><font color="Tomato"><strong>如若本文有瑕疵需修改的地方，请提出来，谢谢您的贡献！</strong></font></p><p><font color=chocolate>欢迎关注微信公众号：小狮子前端Vue</font></p><p>谢谢您的支持！✿✿ヽ(°▽°)ノ✿</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录腾讯一面（IMWeb团队）</title>
      <link href="/posts/tencentOne/"/>
      <url>/posts/tencentOne/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>面试总时长大约100分钟，下午3点面试，结束接近5点样子。总体感觉就是体会到了差距，但也算是一次历练吧，大场面我都经历过了，也无惧小场面了。下面就将面经分享一下，主要是分享一下题目把，答案网上应该都能找到。</p><p>PS：<code>题目肯定是不唯一的，写这篇博客的原因：</code></p><ul><li>记录总结这次面试</li><li>分享一下面经</li><li>体会差距，努力学习</li></ul><p>注：不代表这套题就是你会被问到的，可以学习一下面试模式</p><p>此次面试官：<font color=chocolate>IMWeb团队 前端架构师</font></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>（关注下面题目，如果有dalao在，可以评论区答复，欢迎交流，我会以数字序号标注题目）</p><h3 id="1、自我介绍"><a href="#1、自我介绍" class="headerlink" title="1、自我介绍"></a>1、自我介绍</h3><p>开场多半都是这样</p><h3 id="2、询问你在大学学了哪些课程，你觉得你学得最好的是哪一门？"><a href="#2、询问你在大学学了哪些课程，你觉得你学得最好的是哪一门？" class="headerlink" title="2、询问你在大学学了哪些课程，你觉得你学得最好的是哪一门？"></a>2、询问你在大学学了哪些课程，你觉得你学得最好的是哪一门？</h3><p>这里的话，接下来的话题就会围绕你觉得学的最好的课程来展开</p><h3 id="3、先用js手写一个冒泡排序"><a href="#3、先用js手写一个冒泡排序" class="headerlink" title="3、先用js手写一个冒泡排序"></a>3、先用js手写一个冒泡排序</h3><p>这期间还问了时间复杂度和空间复杂度，空间复杂度与什么因素有关</p><h3 id="4、你知道打开https-www-qq-com经历了什么吗？"><a href="#4、你知道打开https-www-qq-com经历了什么吗？" class="headerlink" title="4、你知道打开https:www.qq.com经历了什么吗？"></a>4、你知道打开https:<a href="http://www.qq.com经历了什么吗？">www.qq.com经历了什么吗？</a></h3><p>这个就是关于输入网址到显示页面的步骤</p><h3 id="5、js基本数据类型"><a href="#5、js基本数据类型" class="headerlink" title="5、js基本数据类型"></a>5、js基本数据类型</h3><p>之前答的不是很好，面试官就回到了简单一点的题</p><h3 id="6、Vue生命周期你有了解过吗？你用到过哪些？"><a href="#6、Vue生命周期你有了解过吗？你用到过哪些？" class="headerlink" title="6、Vue生命周期你有了解过吗？你用到过哪些？"></a>6、Vue生命周期你有了解过吗？你用到过哪些？</h3><p>beforeCreate 、created 等等</p><h3 id="7、你知道cookie吗？请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#7、你知道cookie吗？请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="7、你知道cookie吗？请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>7、你知道cookie吗？请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><p>这里也问了cookies里面重要属性有哪些，有什么用</p><h3 id="8、你了解SEO吗？知道怎么做吗？"><a href="#8、你了解SEO吗？知道怎么做吗？" class="headerlink" title="8、你了解SEO吗？知道怎么做吗？"></a>8、你了解SEO吗？知道怎么做吗？</h3><p>这里我就答了html5一些，以及搭建hexo博客用的优化，还提及到了SEO有什么用</p><h3 id="9、谈谈你对this的理解"><a href="#9、谈谈你对this的理解" class="headerlink" title="9、谈谈你对this的理解"></a>9、谈谈你对this的理解</h3><p>因为提及到了apply和call，面试官就反问了apply和call的知识</p><h3 id="10、你了解跨域吗？"><a href="#10、你了解跨域吗？" class="headerlink" title="10、你了解跨域吗？"></a>10、你了解跨域吗？</h3><p>我在谈及的时候，提及到了前后端分离模式，于是下一题…</p><h3 id="11、说说你对前后端分离的理解"><a href="#11、说说你对前后端分离的理解" class="headerlink" title="11、说说你对前后端分离的理解"></a>11、说说你对前后端分离的理解</h3><p>我就从JSONP时代讲到了nginx反向代理，也从原本不需要考虑跨域问题谈到现在比较主流的前后端分离模式</p><h3 id="12、你对浏览器的理解，本地打开浏览器经历了什么？"><a href="#12、你对浏览器的理解，本地打开浏览器经历了什么？" class="headerlink" title="12、你对浏览器的理解，本地打开浏览器经历了什么？"></a>12、你对浏览器的理解，本地打开浏览器经历了什么？</h3><p>这个当时有点懵…</p><h3 id="13、谈谈你所了解的前端性能优化？"><a href="#13、谈谈你所了解的前端性能优化？" class="headerlink" title="13、谈谈你所了解的前端性能优化？"></a>13、谈谈你所了解的前端性能优化？</h3><p>代码压缩，SEO、缓存等等</p><h3 id="14、你知道gulp吗？"><a href="#14、你知道gulp吗？" class="headerlink" title="14、你知道gulp吗？"></a>14、你知道gulp吗？</h3><p>流…</p><h3 id="15、你用过git吗？常见哪些指令？你知道回退是什么指令吗？"><a href="#15、你用过git吗？常见哪些指令？你知道回退是什么指令吗？" class="headerlink" title="15、你用过git吗？常见哪些指令？你知道回退是什么指令吗？"></a>15、你用过git吗？常见哪些指令？你知道回退是什么指令吗？</h3><h3 id="16、你了解React吗？"><a href="#16、你了解React吗？" class="headerlink" title="16、你了解React吗？"></a>16、你了解React吗？</h3><p>因为不是很了解，这里我就谈及了mvvm和mvc的区别，也说明了为啥选择学习Vue，作为学生目前了解不是很深入</p><h3 id="17、你知道怎么不传cookied吗？你了解过http-only吗？"><a href="#17、你知道怎么不传cookied吗？你了解过http-only吗？" class="headerlink" title="17、你知道怎么不传cookied吗？你了解过http:only吗？"></a>17、你知道怎么不传cookied吗？你了解过http:only吗？</h3><p>这个我就有点熟悉，但不记得了</p><h3 id="18、你了解Webpack吗？"><a href="#18、你了解Webpack吗？" class="headerlink" title="18、你了解Webpack吗？"></a>18、你了解Webpack吗？</h3><p>打包方面</p><h3 id="19、对于之前打开本地浏览器那一块，你了解过dom树吗？"><a href="#19、对于之前打开本地浏览器那一块，你了解过dom树吗？" class="headerlink" title="19、对于之前打开本地浏览器那一块，你了解过dom树吗？"></a>19、对于之前打开本地浏览器那一块，你了解过dom树吗？</h3><p>好像他也想问AST语法树方面，但我也不记得了</p><h3 id="20、你了解CDN吗？在哪里你用过"><a href="#20、你了解CDN吗？在哪里你用过" class="headerlink" title="20、你了解CDN吗？在哪里你用过"></a>20、你了解CDN吗？在哪里你用过</h3><h3 id="21、说说你对原型链的理解？"><a href="#21、说说你对原型链的理解？" class="headerlink" title="21、说说你对原型链的理解？"></a>21、说说你对原型链的理解？</h3><h3 id="22、谈谈你对响应式原理的理解"><a href="#22、谈谈你对响应式原理的理解" class="headerlink" title="22、谈谈你对响应式原理的理解"></a>22、谈谈你对响应式原理的理解</h3><p>我提及到了Vue2.0和Vue3.0 区别 以及proxy还能做些什么</p><h3 id="23、你了解闭包吗？"><a href="#23、你了解闭包吗？" class="headerlink" title="23、你了解闭包吗？"></a>23、你了解闭包吗？</h3><h3 id="24、leetcode-电话号码的字母组合"><a href="#24、leetcode-电话号码的字母组合" class="headerlink" title="24、leetcode  电话号码的字母组合"></a>24、leetcode  电话号码的字母组合</h3><p>题目</p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200327100131518.png"  alt=""></p><p>示例:<br>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><h3 id="25、最后，出了4到题"><a href="#25、最后，出了4到题" class="headerlink" title="25、最后，出了4到题"></a>25、最后，出了4到题</h3><p>① 异步、事件循环方面，具体题不急得了，但你能把下面这道题做出来，基本上没问题</p><p><a href="https://chocolate.blog.csdn.net/article/details/104907304" target="_blank" rel="noopener">原题地址及解析</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;挑战js面试题&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">            <span class="keyword">await</span> async2();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">        async1();</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>② 你如何将arguments参数改变为数组</p><p>③ box-sizing中content和border的区别</p><p>讲解各种盒模型：标准盒模型、IE（怪异）盒模型、flex、分列布局</p><p>④ 请你用正则表达式来解析腾讯qq或者腾讯其它网页的域名</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>好了，距离上次面试也过了两天了，我才打算写一份面经，有些题目可能不太记得了，如果后续学习的时候想到了，我会在评论区进行补充，100多分钟，想不到还问了这么多题…而且有些题目我还进行了深入探讨，比如对闭包，对v8引擎，Vue中响应式原理那一块探索设计模式。</p><p>尽管凉了，但也是一次不错的体验吧，<code>跌倒了一次，爬起来，继续走下去</code>…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 腾讯 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端全家桶（面试题大整理）</title>
      <link href="/posts/vue-family/"/>
      <url>/posts/vue-family/</url>
      
        <content type="html"><![CDATA[<h2 id="面试准备——自我介绍"><a href="#面试准备——自我介绍" class="headerlink" title="面试准备——自我介绍"></a>面试准备——自我介绍</h2><h2 id="一面-二面"><a href="#一面-二面" class="headerlink" title="一面 / 二面"></a>一面 / 二面</h2><h3 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h3><ul><li>准备要充分</li><li>知识要系统</li><li>沟通要简洁</li><li>内心要诚实</li><li>态度要谦虚</li><li>回答要灵活</li></ul><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>假设高度已知，请写出三栏布局，其中左、右栏宽度各为300px，中间自适应</strong></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402113527886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h3 id="五种解决方式代码"><a href="#五种解决方式代码" class="headerlink" title="五种解决方式代码"></a>五种解决方式代码</h3><ul><li>浮动解决方式</li><li>绝对定位解决方式</li><li>flexbox解决方式</li><li>表格布局</li><li>网格布局</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Layout&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        html *&#123;</span></span><br><span class="line"><span class="regexp">            padding: 0;</span></span><br><span class="line"><span class="regexp">            margin: 0;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .layout&#123;</span></span><br><span class="line"><span class="regexp">            margin-top: 20px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .layout article div&#123;</span></span><br><span class="line"><span class="regexp">            min-height: 100px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 浮动解决方式 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;section class="layout float"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;style&gt;</span></span><br><span class="line"><span class="regexp">            .layout.float .left&#123;</span></span><br><span class="line"><span class="regexp">                float: left;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: red;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.float .right&#123;</span></span><br><span class="line"><span class="regexp">                float: right;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: blue;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.float .center&#123;</span></span><br><span class="line"><span class="regexp">                background: yellow;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"left-right-center"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="right"&gt;&lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"center"</span>&gt;</span><br><span class="line">                &lt;h1&gt;浮动解决方式&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                1.这是三栏布局的正中间部分</span></span><br><span class="line"><span class="regexp">                2.这是三栏布局的正中间部分</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/article&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>section&gt;</span><br><span class="line">    &lt;!-- 绝对定位解决方式 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"layout absolute"</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.absolute .left-center-right&gt;div&#123;</span><br><span class="line">                position: absolute;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.absolute .left&#123;</span><br><span class="line">                left: <span class="number">0</span>;</span><br><span class="line">                width: <span class="number">300</span>px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.absolute .center&#123;</span><br><span class="line">                left: <span class="number">300</span>px;</span><br><span class="line">                right: <span class="number">300</span>px;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.absolute .right&#123;</span><br><span class="line">                right: <span class="number">0</span>;</span><br><span class="line">                width: <span class="number">300</span>px;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">        &lt;article class="left-center-right"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="left"&gt;&lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"center"</span>&gt;</span><br><span class="line">                &lt;h1&gt;绝对定位解决方式&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                1.这是三栏布局的正中间部分</span></span><br><span class="line"><span class="regexp">                2.这是三栏布局的正中间部分</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"right"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>article&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- flexbox解决方式 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;section class="layout flexbox"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;style&gt;</span></span><br><span class="line"><span class="regexp">            .layout.flexbox&#123;</span></span><br><span class="line"><span class="regexp">                margin-top: 140px;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.flexbox .left-center-right&#123;</span></span><br><span class="line"><span class="regexp">                display: flex;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.flexbox .left&#123;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: red;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.flexbox .center&#123;</span></span><br><span class="line"><span class="regexp">                flex: 1;</span></span><br><span class="line"><span class="regexp">                background: yellow;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.flexbox .right&#123;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: blue;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"left-center-right"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="center"&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h1&gt;flexbox解决方式&lt;/</span>h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="right"&gt;&lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/article&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>section&gt;</span><br><span class="line">    &lt;!-- 表格布局 --&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"layout table"</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .layout.table .left-center-right&#123;</span><br><span class="line">                width: <span class="number">100</span>%;</span><br><span class="line">                display: table;</span><br><span class="line">                height: <span class="number">100</span>px;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .left-center-right&gt;div&#123;</span><br><span class="line">                display: table-cell;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .left&#123;</span><br><span class="line">                width: <span class="number">300</span>px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .center&#123;</span><br><span class="line">                background: yellow;</span><br><span class="line">            &#125;</span><br><span class="line">            .layout.table .right&#123;</span><br><span class="line">                width: <span class="number">300</span>px;</span><br><span class="line">                background: blue;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">        &lt;article class="left-center-right"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="left"&gt;&lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"center"</span>&gt;</span><br><span class="line">                &lt;h1&gt;表格解决方式&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                1.这是三栏布局的正中间部分</span></span><br><span class="line"><span class="regexp">                2.这是三栏布局的正中间部分</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"right"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>article&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 网格布局 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;section class="layout grid"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;style&gt;</span></span><br><span class="line"><span class="regexp">            .layout.grid .left-center-right&#123;</span></span><br><span class="line"><span class="regexp">                display: grid;</span></span><br><span class="line"><span class="regexp">                width: 100%;</span></span><br><span class="line"><span class="regexp">                grid-template-rows: 100px;</span></span><br><span class="line"><span class="regexp">                grid-template-columns: 300px auto 300px;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.grid .left&#123;</span></span><br><span class="line"><span class="regexp">                background: red;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.grid .center&#123;</span></span><br><span class="line"><span class="regexp">                background: yellow;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.grid .right&#123;</span></span><br><span class="line"><span class="regexp">                background: blue;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"left-center-right"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="center"&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h1&gt;网格解决方式&lt;/</span>h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="right"&gt;&lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/article&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>section&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><h3 id="展示效果"><a href="#展示效果" class="headerlink" title="展示效果"></a>展示效果</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402134031526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h3 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h3><p>上述5中解决方式是比较常见的，但是我们<code>不能只局限于为了问答而问答，我们应该从此基础上升华一下问题。</code></p><p>答完了这5种常见方式，并不代表我们页面布局这一话题就结束了，面试官可能还会延伸我们的问题，比如：</p><ul><li>这5种布局方式各自有什么优点和缺点？</li><li>如果<code>高度已知</code>条件去掉，考虑纵向，那么对于中间内容过多，导致中间格子撑开，此时需要左右跟着撑开，以上5种方式哪几种还能使用？</li><li>这5中方式的兼容性如何？如果让你选择一种最优的去应用于业务，你会选择哪种方式？</li></ul><p>那么，接下来就来围绕这三个问题来讲解：</p><h3 id="1、各自的优缺点"><a href="#1、各自的优缺点" class="headerlink" title="1、各自的优缺点"></a>1、各自的优缺点</h3><p><strong>① 对于浮动：</strong></p><p><strong>优点</strong></p><p>兼容性比较好，把清除浮动和其它浮动周边元素的关系处理好的话，那么它的兼容性是挺不错的。</p><p><strong>缺点</strong></p><p>设置浮动之后，脱离了文档流，处理不好的话，会带来很多问题，这是它本身的局限性。</p><p><strong>② 对于绝对定位：</strong></p><p><strong>优点</strong></p><p>快捷，不容易出问题</p><p><strong>缺点</strong></p><p>本身脱离了文档流，就会导致子元素跟着脱离文档流。因此，导致绝对定位的<code>有效性</code>、<code>可使用性</code>比较差。</p><p><strong>③ 对于flexbox</strong></p><p>css3中推出的flex布局，就是为了解决上述两种方式不足而出现的，算是比较完美的一种方式，尤其是对于移动端</p><p><strong>④ 对于表格布局</strong></p><p><strong>优点</strong></p><p>尽管多数人吐槽表格布局，但其实，表格布局在很多场景都适用的。比如上文写的三栏布局设计当中，表格布局是不是很轻松就实现了呢？</p><p>同时，表格布局的兼容性是非常好的，当用<code>flex</code>解决不了问题的时候，对于PC端  <code>IE8</code>是不支持<code>flex</code>的，此时就可以尝试表格布局</p><p><strong>缺点</strong></p><p>除开历史上一些诟病外，还有一个：</p><p>比如我们把三栏理解成为三个小单元格，那么当其中某一个单元格高度超出的时候，其余两侧也会跟着调整，于是对于有些场景是不合适的。因此，对于不同场景，我们可以在<code>flex</code>和<code>表格</code>布局进行选优操作</p><p><strong>⑤ 对于网格布局</strong></p><p>这一块的话，算是新热点，也是经历了一段时间的演变，从上文代码来看的话，通过网格布局我们能让代码更加简单、方便实现逻辑。在面试的时候提到也可以说明你比较关注新的事物，主动学习能力不错。</p><hr/><p>当然，以上表述有部分个人思考，也有现常说的优缺点，读者可以根据研究布局方式进行深入思考，学习更多的使用场景以及优缺点，其次，欢迎提出新的解决方案及相关知识点，后续进行补充。</p><h3 id="2、去掉高度，有哪几种布局可以使用？"><a href="#2、去掉高度，有哪几种布局可以使用？" class="headerlink" title="2、去掉高度，有哪几种布局可以使用？"></a>2、去掉高度，有哪几种布局可以使用？</h3><p>这里，我们就采用增加高度方式来看看，还有哪些布局能使用。（中间区域增加几个p标签）</p><p><strong>源代码</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Layout&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        html *&#123;</span></span><br><span class="line"><span class="regexp">            padding: 0;</span></span><br><span class="line"><span class="regexp">            margin: 0;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .layout&#123;</span></span><br><span class="line"><span class="regexp">            margin-top: 20px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .layout article div&#123;</span></span><br><span class="line"><span class="regexp">            min-height: 100px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 浮动解决方式 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;section class="layout float"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;style&gt;</span></span><br><span class="line"><span class="regexp">            .layout.float .left&#123;</span></span><br><span class="line"><span class="regexp">                float: left;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: red;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.float .right&#123;</span></span><br><span class="line"><span class="regexp">                float: right;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: blue;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.float .center&#123;</span></span><br><span class="line"><span class="regexp">                background: yellow;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"left-right-center"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="right"&gt;&lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"center"</span>&gt;</span><br><span class="line">                &lt;h1&gt;浮动解决方式&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                1.这是三栏布局的正中间部分</span></span><br><span class="line"><span class="regexp">                2.这是三栏布局的正中间部分</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;增加高度&lt;/</span>p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;增加高度&lt;/</span>p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;增加高度&lt;/</span>p&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>article&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 绝对定位解决方式 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;section class="layout absolute"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;style&gt;</span></span><br><span class="line"><span class="regexp">            .layout.absolute .left-center-right&gt;div&#123;</span></span><br><span class="line"><span class="regexp">                position: absolute;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.absolute .left&#123;</span></span><br><span class="line"><span class="regexp">                left: 0;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: red;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.absolute .center&#123;</span></span><br><span class="line"><span class="regexp">                left: 300px;</span></span><br><span class="line"><span class="regexp">                right: 300px;</span></span><br><span class="line"><span class="regexp">                background: yellow;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.absolute .right&#123;</span></span><br><span class="line"><span class="regexp">                right: 0;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: blue;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"left-center-right"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="center"&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h1&gt;绝对定位解决方式&lt;/</span>h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;增加高度&lt;/</span>p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;增加高度&lt;/</span>p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"right"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>article&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- flexbox解决方式 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;section class="layout flexbox"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;style&gt;</span></span><br><span class="line"><span class="regexp">            .layout.flexbox&#123;</span></span><br><span class="line"><span class="regexp">                margin-top: 140px;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.flexbox .left-center-right&#123;</span></span><br><span class="line"><span class="regexp">                display: flex;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.flexbox .left&#123;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: red;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.flexbox .center&#123;</span></span><br><span class="line"><span class="regexp">                flex: 1;</span></span><br><span class="line"><span class="regexp">                background: yellow;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.flexbox .right&#123;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: blue;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"left-center-right"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="center"&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h1&gt;flexbox解决方式&lt;/</span>h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;增加高度&lt;/</span>p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;增加高度&lt;/</span>p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"right"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>article&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 表格布局 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;section class="layout table"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;style&gt;</span></span><br><span class="line"><span class="regexp">            .layout.table .left-center-right&#123;</span></span><br><span class="line"><span class="regexp">                width: 100%;</span></span><br><span class="line"><span class="regexp">                display: table;</span></span><br><span class="line"><span class="regexp">                height: 100px;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.table .left-center-right&gt;div&#123;</span></span><br><span class="line"><span class="regexp">                display: table-cell;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.table .left&#123;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: red;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.table .center&#123;</span></span><br><span class="line"><span class="regexp">                background: yellow;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.table .right&#123;</span></span><br><span class="line"><span class="regexp">                width: 300px;</span></span><br><span class="line"><span class="regexp">                background: blue;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"left-center-right"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="center"&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h1&gt;表格解决方式&lt;/</span>h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;增加高度&lt;/</span>p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;增加高度&lt;/</span>p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"right"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>article&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- 网格布局 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;section class="layout grid"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;style&gt;</span></span><br><span class="line"><span class="regexp">            .layout.grid .left-center-right&#123;</span></span><br><span class="line"><span class="regexp">                display: grid;</span></span><br><span class="line"><span class="regexp">                width: 100%;</span></span><br><span class="line"><span class="regexp">                grid-template-rows: 100px;</span></span><br><span class="line"><span class="regexp">                grid-template-columns: 300px auto 300px;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.grid .left&#123;</span></span><br><span class="line"><span class="regexp">                background: red;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.grid .center&#123;</span></span><br><span class="line"><span class="regexp">                background: yellow;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .layout.grid .right&#123;</span></span><br><span class="line"><span class="regexp">                background: blue;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"left-center-right"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="center"&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h1&gt;网格解决方式&lt;/</span>h1&gt;</span><br><span class="line">                <span class="number">1.</span>这是三栏布局的正中间部分</span><br><span class="line">                <span class="number">2.</span>这是三栏布局的正中间部分</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;增加高度&lt;/</span>p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;p&gt;增加高度&lt;/</span>p&gt;</span><br><span class="line">                &lt;p&gt;增加高度&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"right"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>article&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p><strong>展示效果</strong></p><p>这里，图片可能不是特别清楚，读者可以跑一遍上述代码，在浏览器打开使用会更好一点嗷~</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402153629282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p><strong>总结</strong></p><p>从上述显示效果来看的话，改变了高度，用<code>flex</code>和<code>表格</code>布局还能继续使用。</p><p>对于第一块，也就是浮动布局那一块，我们还可以进行知识拓展：</p><ul><li><p>为什么会有两段文字跑到最左边去了呢？</p><p>  答：因为向左浮动的原因，上面文字被左边红色部分挡住了，当内容超过高度后，就会往左边移动了。</p></li><li><p>那你怎么将多余的两段文字接着上述文字显示，而不是向左移动？</p><p>  答：这就扯到了BFC的问题，清楚浮动等等，这里就不再进行拓展了，不然这篇文章没法完结啦。。。</p></li></ul><h3 id="页面布局模块——总结"><a href="#页面布局模块——总结" class="headerlink" title="页面布局模块——总结"></a>页面布局模块——总结</h3><ul><li>语义化掌握到位</li><li>页面布局深刻理解</li><li>CSS基础扎实</li><li>思维灵活且积极上进</li><li>代码书写规范</li></ul><h3 id="页面布局的变通"><a href="#页面布局的变通" class="headerlink" title="页面布局的变通"></a>页面布局的变通</h3><p><strong>三栏布局</strong></p><ul><li>左右宽度固定，中间自适应</li><li>上下高度固定，中间自适应</li></ul><p><strong>两栏布局</strong></p><ul><li>左宽度固定，右自适应</li><li>右宽度固定，左自适应</li><li>上宽度固定，下自适应</li><li>下宽度固定，上自适应</li></ul><h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><strong>谈谈你对CSS盒模型的认识</strong></p><ul><li><p>基本概念：标准模型+IE模型</p></li><li><p>标准模型和IE模型的区别</p></li><li><p>CSS如何设置这两种盒模型</p></li><li><p>JS如何设置获取盒模型对应的宽和高</p></li><li><p>实例题（根据盒模型解释边距重叠）</p></li><li><p>BFC（边距重叠解决方案）</p></li></ul><hr/><p>以上内容知识点由浅入深，知识点理论从CSS-&gt;JS-&gt;CSS</p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104448450" target="_blank" rel="noopener">推荐阅读：这一次，彻底看懂 CSS 盒模型（图文并茂）</a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>标准盒模型、怪异盒模型（IE盒模型）和flex弹性伸缩盒模型以及多列布局</p><ul><li>标准盒模型（box-sizing content-box）</li></ul><p> class="lazyload" data-src="https://img-blog.csdnimg.cn/20200222185449952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" <img src="/"></img></p><ul><li>IE盒模型（box-sizing border-box）</li></ul><p>content = width+padding+border</p><p> class="lazyload" data-src="https://img-blog.csdnimg.cn/20200222185613912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70" <img src="/"></img></p><p><strong><font color=red>附完美回答方式：</font></strong></p><p>标准盒子模型，即box-sizing content-box，浏览器默认模型，我们所写的width和height并不是最终盒子的宽高，而是content的，盒子的宽高由我们的content+padding+border来组成的，但是这样在做项目时可能会遇到小问题，假如我想构建一个100x100的盒子大小，但是我发现我写的是width和height是100，于是我需要加上padding及border，但是加上去之后，盒子也会相应变大，这就造成改动麻烦。</p><p>后面css3中提供了IE盒子模型，能够直接控制盒子的大小。于是项目中大多数用上了IE盒子模型，以及我看过bootstrap以及element-ui源码中大部分也是用的IE盒子模型</p><blockquote><div>以上回答方式，请读者可以好好体会一下，挖掘其中的亮点！</div></blockquote><ul><li>FLEX盒模型</li></ul><p>关于这里可以参考阮一峰老师的文章</p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">参考：Flex 布局教程：语法篇</a></p><ul><li>多列布局（基本上不用）</li></ul><p>读者可以适当了解一下，这里就不加以说明了</p><h3 id="JS如何获取盒模型对应的宽和高"><a href="#JS如何获取盒模型对应的宽和高" class="headerlink" title="JS如何获取盒模型对应的宽和高"></a>JS如何获取盒模型对应的宽和高</h3><p>①<code>dom.style.width / height</code></p><p>这种方法，有一定局限性，只能取内联样式的宽高。</p><p>②<code>dom.currentStyle.width / height</code></p><p>这种方法，也是有一定局限性，不过我们三种常用css样式都能获取。但是只支持<code>IE</code>，其它浏览器不支持</p><p>③ <code>window.getComputedStyle(dom).width / height</code></p><p>支持所有浏览器，兼容性好</p><p>④ <code>dom.getBoundingClientRect().width / height</code></p><p>这种方法，一般用于计算元素的绝对位置，根据视窗左上角的点来算的。可以拿到四个元素值：<code>left</code>、<code>top</code>、<code>width</code>、<code>height</code></p><h3 id="实例题（根据盒模型解释边距重叠）"><a href="#实例题（根据盒模型解释边距重叠）" class="headerlink" title="实例题（根据盒模型解释边距重叠）"></a>实例题（根据盒模型解释边距重叠）</h3><p>如下图，有两个盒子，深色的定为父元素，浅色的定位子元素，子元素的高度为<code>100px</code>，与父元素的上边距为<code>10px</code>，请问父元素实际高度是多少？<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402165051784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p>结合这个标题的情况，你可能会说是100px，但你也可能就是直接相加，觉得是110px，但都不是面试官觉得满意的回答，因为要看父元素的盒模型是如何设置的，下面来探讨这个问题：</p><p>我们在界面里来写一个父子元素的盒子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;CSS盒模型&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        html *&#123;</span></span><br><span class="line"><span class="regexp">            padding: 0%;</span></span><br><span class="line"><span class="regexp">            margin: 0;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;section id="sec"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;style&gt;</span></span><br><span class="line"><span class="regexp">            #sec&#123;</span></span><br><span class="line"><span class="regexp">                background: #f00;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .children&#123;</span></span><br><span class="line"><span class="regexp">                height: 100px;</span></span><br><span class="line"><span class="regexp">                margin-top: 10px;</span></span><br><span class="line"><span class="regexp">                background: yellow;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"children"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;<span class="regexp">/article&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>section&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p>打开浏览器，出现如下界面：<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402190607634.png"  alt=""></p><p> 我们父级元素貌似没看到，打开开发者工具（按下<code>F12</code>）</p><p>此时，我们看一下计算属性 <code>Computed</code></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402192214142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>发现，此时高度是<code>100px</code>。</p><p>同时，我们也看一下子元素的高度，如下，也是<code>100px</code>。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402192306678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p>那是不是就是<code>100px</code>呢？在回答之前，接着来如下操作，我们修改一个地方：</p><p>在父元素样式里设置 <code>overflow: hidden;</code><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040219294052.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>此时，我们再次查看content，变成了<code>110px</code>。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402201211584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>此时，就有疑问了，为什么之前是<code>100px</code>，而当我们加了<code>overflow: hidden;</code>之后变成了<code>110px</code>了呢？</p><p><strong>补充知识点：</strong></p><p>我们常见的边距重叠，有两种情况：</p><ul><li>父子元素重叠（如上文所述）</li><li>兄弟之间重叠：比如两个格子，第一个格子下边距30px，第二个上边距5px，会取一个最大值30px作为边距。另外，特殊一点的就是空元素了，会取<code>margin-top</code>和<code>margin-bottom</code><br>的最大值</li></ul><p>补充完后，接着回答上一个问题，为什么加了<code>overflow: hidden;</code>之后变成了<code>110px</code>了呢？</p><p>其实，是给父级元素创建了一个<code>BFC</code>，这里我们在下文继续讨论。</p><h3 id="BFC（边距重叠解决方案）"><a href="#BFC（边距重叠解决方案）" class="headerlink" title="BFC（边距重叠解决方案）"></a>BFC（边距重叠解决方案）</h3><p><strong>BFC基本概念</strong>：块级格式化上下文</p><p>与之并列的一个是IFC（内联格式化上下文）这个不常考，就提一下。</p><p><strong>BFC的原理（渲染规则）</strong></p><p>① 在BFC这个元素的<code>垂直方向</code>边距会发生重叠</p><p>② BFC的区域不会与浮动元素的box重叠，可用来<code>清除</code>浮动布局</p><p>③ BFC是一个<code>独立</code>的容器，外面的元素不会影响里面的元素，同时，里面的元素不会影响外面的元素。</p><p>④ 计算BFC元素高度的时候，<code>浮动元素也会参与计算</code></p><p><strong>怎么创建BFC？</strong></p><p>① <code>float</code>值不为none，因为CSS默认为none，只要设置了浮动，当前元素就设置了BFC</p><p>② static：静态定位。它是<code>position</code>的默认值，一般不设置position属性时，元素会按照正常的文档流进行排列。那么，只要position不为默认值static也是设置了BFC</p><p>③ <code>display</code>属性，table、table-cell等table相关的，都是设置了BFC</p><p>④ <code>overflow</code>: auto / hidden</p><p><strong>BFC使用场景</strong></p><h3 id="垂直方向边距重叠问题"><a href="#垂直方向边距重叠问题" class="headerlink" title="垂直方向边距重叠问题"></a>垂直方向边距重叠问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;CSS盒模型&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        html *&#123;</span></span><br><span class="line"><span class="regexp">            padding: 0%;</span></span><br><span class="line"><span class="regexp">            margin: 0;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;section id="sec"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;style&gt;</span></span><br><span class="line"><span class="regexp">            #sec&#123;</span></span><br><span class="line"><span class="regexp">                background: #f00;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            .children&#123;</span></span><br><span class="line"><span class="regexp">                height: 100px;</span></span><br><span class="line"><span class="regexp">                margin-top: 10px;</span></span><br><span class="line"><span class="regexp">                background: yellow;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>style&gt;</span><br><span class="line">        &lt;article <span class="class"><span class="keyword">class</span></span>=<span class="string">"children"</span>&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;<span class="regexp">/article&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>section&gt;</span><br><span class="line">    &lt;!-- BFC垂直方向边距重叠 --&gt;</span><br><span class="line">    &lt;section id=<span class="string">"margin"</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #margin&#123;</span><br><span class="line">                background: pink;</span><br><span class="line">                overflow: hidden;</span><br><span class="line">            &#125;</span><br><span class="line">            #margin&gt;p&#123;</span><br><span class="line">                margin: <span class="number">5</span>px auto <span class="number">25</span>px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;a&lt;/</span>p&gt;</span><br><span class="line">        &lt;p&gt;b&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;c&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>如下图所示，a的顶部只有5px，而b的顶部用到了a的底部25px，因此就造成了边距重叠问题<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402204846508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>如何消除上述情况？</p><p>给子元素创建父元素，让父元素设置BFC</p><p>如下图所示，仅需加一个div，然后设置<code>overflow: hidden</code>即可</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402211309341.png"  alt=""></p><p><strong>效果</strong></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402211300463.png"  alt=""></p><p>接下来，来一个左边固定，右边自适应的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- BFC不予float重叠 --&gt;</span><br><span class="line">&lt;section id=<span class="string">"layout"</span>&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #layout&#123;</span><br><span class="line">            margin-top: <span class="number">10</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        #layout .left&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line">        #layout .right&#123;</span><br><span class="line">            height: <span class="number">110</span>px;</span><br><span class="line">            background: #ccc;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="left"&gt;&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"right"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>section&gt;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402212208404.png"  alt=""><br>从上图可以看到，右边因为宽度设置的高一点，经过浮动重叠到了左边一部分，此时，我们仅需一行代码即可<code>overflow: auto;</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#layout .right&#123;</span><br><span class="line">height: <span class="number">110</span>px;</span><br><span class="line">background: #ccc;</span><br><span class="line">overflow: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402212438518.png"  alt=""></p><p><strong>计算BFC元素高度的时候，浮动元素也会参与计算</strong></p><p>怎么理解这个概念呢？比如下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- BFC子元素即使是float也会参与高度计算 --&gt;</span><br><span class="line">&lt;section id=<span class="string">"float"</span>&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #float&#123;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">        #float .float&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            font-size: <span class="number">30</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="float"&gt;I am 浮动元素&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/section&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402223151584.png"  alt=""><br>我们从上面图片发现，没有父级元素，于是检查一下，发现父级高度为0，因为子元素设置了浮动，高度没有算进去<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402223510992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p>解决办法，父级元素设置清除浮动，于是形成了一个BFC，然后就会加上子级元素的高度</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#float&#123;</span><br><span class="line">background: green;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从门再次打开开发者工具（F12），可以看到，父级元素已经有了高度</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200402223829514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h2 id="DOM-事件类"><a href="#DOM-事件类" class="headerlink" title="DOM 事件类"></a>DOM 事件类</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><ul><li><p>基本概念：DOM事件的级别</p></li><li><p>DOM事件模型</p></li><li><p>DOM事件流</p></li><li><p>描述DOM事件捕获的具体流程</p></li><li><p>Event对象的常见应用</p></li><li><p>自定义事件</p></li></ul><h3 id="基本概念：DOM事件的级别"><a href="#基本概念：DOM事件的级别" class="headerlink" title="基本概念：DOM事件的级别"></a>基本概念：DOM事件的级别</h3><table><thead><tr><th align="center">DMO事件类</th><th align="center">事件级别</th></tr></thead><tbody><tr><td align="center">DOM0</td><td align="center">element.onclick=function(){}</td></tr><tr><td align="center">DOM2</td><td align="center">element.addEventListener(‘click’, function(){} , false)</td></tr><tr><td align="center">DOM3</td><td align="center">element.addEventListener(‘keyup’, function(){} , false)</td></tr></tbody></table><p>为啥没有DOM1呢？</p><p>答：因为DOM1制定的时候，没有设计与事件相关的东西，但不代表DOM1标准不存在</p><p>DOM3也是一种事件定义方式，相对来说事件类型增加了，比如鼠标键盘事件等</p><p>最后一个<code>boolean</code>值表示事件模型是捕获还是冒泡，默认为<code>false</code>冒泡，为<code>true</code>表示捕获。</p><h3 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h3><p>分为捕获（从上到下）和冒泡（从目标元素往上）</p><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200403093615164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>如上图所示，这就是一个事件流，一个<code>完整的事件流</code>分为三个阶段：</p><ul><li>第一阶段是捕获</li><li>第二阶段是目标阶段，比如说点按钮就是目标阶段，或者说是事件通过捕获到达目标元素</li><li>第三阶段是从目标元素上传到window对象，也就是冒泡的过程</li></ul><h3 id="描述DOM事件捕获的具体流程"><a href="#描述DOM事件捕获的具体流程" class="headerlink" title="描述DOM事件捕获的具体流程"></a>描述DOM事件捕获的具体流程</h3><p>（冒泡方向与之相反）<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040309413230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h3 id="Event对象的常见应用"><a href="#Event对象的常见应用" class="headerlink" title="Event对象的常见应用"></a>Event对象的常见应用</h3><ul><li><code>event.preventDefault()</code>        （阻止默认，例如链接等）</li><li><code>event.stopPropagation()</code>    （阻止冒泡）</li><li><code>event.stopImmediateProgation()</code>         （事件响应优先级，例如给一个按钮添加两个事件A和B，你想要只执行A，不执行B，就在A的响应函数里添加这个方法，就会阻止B事件的执行）</li><li><code>event.currentTarget</code>        （表示当前所绑定的事件，如下面所述，指向的就是父级元素）</li><li><code>event.target</code>    （与事件委托相关，把子元素的事件全都转到父级元素上，进行优化，只需绑定一次事件，然而作响应的时候，需要区别是哪个子元素被点击，该方法就可以绑定当前被点击的元素）</li></ul><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> eve = <span class="keyword">new</span> Event(<span class="string">'custome'</span>);</span><br><span class="line">ev.addEventListener(<span class="string">'custome'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'custome'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">ev.dispatchEvent(eve);</span><br></pre></td></tr></table></figure><p><code>CustomEvent</code>是为了解决Event事件不能传数据的问题</p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>上文讲述了相关知识点，下面我们通过代码来简单实现，让抽象的知识更加具体化</p><p><strong>DOM事件捕获的具体流程实例</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"ev"</span>&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #ev&#123;</span><br><span class="line">                width: <span class="number">300</span>px;</span><br><span class="line">                height: <span class="number">100</span>px;</span><br><span class="line">                color: #fff;</span><br><span class="line">                text-align: center;</span><br><span class="line">                line-height: <span class="number">100</span>px;</span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">        目标元素</span></span><br><span class="line"><span class="regexp">        &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">            var ev=document.getElementById('ev');</span></span><br><span class="line"><span class="string">            //DOM2中定义事件 window</span></span><br><span class="line"><span class="string">            window.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="string">                console.log('window capture')</span></span><br><span class="line"><span class="string">            &#125;,true)</span></span><br><span class="line"><span class="string">            //document</span></span><br><span class="line"><span class="string">            document.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="string">                console.log('document capture')</span></span><br><span class="line"><span class="string">            &#125;,true)</span></span><br><span class="line"><span class="string">            //html</span></span><br><span class="line"><span class="string">            document.documentElement.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="string">                console.log('html capture')</span></span><br><span class="line"><span class="string">            &#125;,true)</span></span><br><span class="line"><span class="string">            //body</span></span><br><span class="line"><span class="string">            document.body.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="string">                console.log('body capture')</span></span><br><span class="line"><span class="string">            &#125;,true)</span></span><br><span class="line"><span class="string">            //目标元素</span></span><br><span class="line"><span class="string">            ev.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="string">                console.log('ev capture')</span></span><br><span class="line"><span class="string">            &#125;,true)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            /* 自定义事件 */</span></span><br><span class="line"><span class="string">            var eve = new Event('test');</span></span><br><span class="line"><span class="string">            ev.addEventListener('test',function()&#123;</span></span><br><span class="line"><span class="string">                console.log('test dispatch')</span></span><br><span class="line"><span class="string">            &#125;,true)</span></span><br><span class="line"><span class="string">            setTimeout(function()&#123;</span></span><br><span class="line"><span class="string">                ev.dispatchEvent(eve);</span></span><br><span class="line"><span class="string">            &#125;,2000)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040311370377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h2 id="HTTP-协议类"><a href="#HTTP-协议类" class="headerlink" title="HTTP 协议类"></a>HTTP 协议类</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><ul><li><p>HTTP协议的主要特点</p></li><li><p>HTTP报文的组成部分</p></li><li><p>HTTP方法</p></li><li><p>POST和GET的区别</p></li><li><p>HTTP状态码</p></li><li><p>什么是持久连接</p></li><li><p>什么是管线化</p></li></ul><h3 id="HTTP协议的主要特点"><a href="#HTTP协议的主要特点" class="headerlink" title="HTTP协议的主要特点"></a>HTTP协议的主要特点</h3><ul><li>简单快速    （每个资源URL是固定的，一个图片或页面地址，统一资源符，只需输入URL即可访问）</li><li>灵活    （在HTTP协议头部head部分有一个数据类型，通过http协议可以完成不同数据类型的传输）</li><li>无连接    （连接一次会断掉，不会保持连接）</li><li>无状态    （客户端和服务端连接两次，不能区分两次连接者身份）</li></ul><h3 id="HTTP报文的组成部分"><a href="#HTTP报文的组成部分" class="headerlink" title="HTTP报文的组成部分"></a>HTTP报文的组成部分</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200403132018916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><ul><li>请求行：包含方法、页面地址、HTTP协议版本</li><li>请求头：key-value值，告诉服务端需要什么内容，要注意什么类型</li><li>空行：告诉服务端请求头结束，接下来是请求体部分了</li><li>请求体：数据部分</li></ul><p>同理，响应报文</p><p><strong>请求示例</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200403135448592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>以上第一行就是请求行，包含<code>GET</code>方法 / 表示首页  <code>HTTP/1.1</code> 表示HTTP协议版本</p><p>后面内容都是请求头，都是<code>key-value</code>键值对</p><p>空行在这里没有显示出来，然后对于请求体就是一些数据部分了。</p><p><strong>响应示例</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200403135749252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p>第一行是状态行，包含HTTP协议版本，协议状态码200</p><p>下面就是响应头了，也是键值对的形式</p><p>下面会有一个空行，类似下面这种效果（下面这条分割横线）</p><hr/><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">获取资源</td></tr><tr><td align="center">POST</td><td align="center">传输资源</td></tr><tr><td align="center">PUT</td><td align="center">更新资源</td></tr><tr><td align="center">DELETE</td><td align="center">删除资源</td></tr><tr><td align="center">HEAD</td><td align="center">获取报文首部</td></tr></tbody></table><h3 id="POST和GET的区别（重点前5条）"><a href="#POST和GET的区别（重点前5条）" class="headerlink" title="POST和GET的区别（重点前5条）"></a>POST和GET的区别（重点前5条）</h3><ul><li><p>get在浏览器回退时是无害的，而post会再次提交请求</p></li><li><p>get请求会被浏览器主动缓存，而post不会，除非手动设置</p></li><li><p>get请求参数会被完整保留在浏览器历史记录里，而post中的参数不会被保留</p></li><li><p>get请求在URL中传送的参数是有长度限制的，而POST没有限制</p></li><li><p>get参数通过URL传递，post放在Request body中</p></li><li><p>get请求只能进行url编码，而post支持多种编码方式</p></li><li><p>对参数的数据类型，get只接受ASCALL字符，而post没有限制</p></li><li><p>get比post更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</p></li><li><p>get产生的URL地址可以被收藏，而post不可以</p></li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul><li>1xx：指示信息——表示请求已接收，继续处理</li><li>2xx：成功——表示请求已经被成功接收</li><li>3xx：重定向——要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误——请求有语法错误或请求无法实现</li><li>5xx：服务器错误——服务器未能实现合法的请求</li></ul><p>一般答完上述基本ok了，如果问的详细一点的话，就多加一点知识上去：</p><ul><li><code>200 OK</code>：客户端请求成功</li><li><code>206 Partial Content</code>：客户发送了一个带有Range（范围）头的GET请求，服务器完成了它（比如客户端请求0-1w字节，服务器就会返回206,常见播放视频和音频地址，文件过大时一般返回206）</li></ul><hr/><ul><li><code>301 Moved Permanently</code>：所请求的页面已经转移至新的URL</li><li><code>302 Found</code>：所请求的页面已经<code>临时</code>转移至新的URL</li><li><code>304 Not  Modified</code>：客户端有<code>缓冲</code>的文档并发出一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用</li></ul><hr/><ul><li><code>400 Bad Request</code>：客户端请求有语法错误，不能被服务器所理解</li><li><code>401 Unauthorized</code>：请求未经授权，这个状态码必须和<code>WWW-Authenticate</code>报头域一起使用</li><li><code>403 Forbidden</code>：请求访问的页面被禁止（比如页面只能通过服务端去访问）</li><li><code>404 Not Found</code>：请求资源不存在</li></ul><hr/><ul><li><code>500 Internal Server Error</code>：服务器发生不可预料的错误但原来缓冲的文档还可以继续使用</li><li><code>503 Server Unavailable</code>：请求未完成，服务器临时过载或当机，一段时候后可能恢复正常</li></ul><h3 id="什么是持久连接"><a href="#什么是持久连接" class="headerlink" title="什么是持久连接"></a>什么是持久连接</h3><p>HTTP协议采用“请求-应答”模式，当使用普通模式，即<code>非 Keep-Alive</code> 模式时，每个请求 / 应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）</p><p>当使用 <code>Keep-Alive</code>模式（又称持久连接、连接重用）时，<code>Keep-Alive</code> 功能使客户端到服务端的连接持续有效，当出现对服务器的后续请求时，<code>Keep-Alive</code> 功能避免了建立或者重新建立连接</p><p>PS：只有HTTP 1.1 版本才支持持久连接，1.0不支持。</p><h3 id="什么是管线化（加分点）"><a href="#什么是管线化（加分点）" class="headerlink" title="什么是管线化（加分点）"></a>什么是管线化（加分点）</h3><p>在使用持久连接的情况下，某个连接上消息的传递类似于</p><p>请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3</p><p>某个连接上的消息类似变成了这样：</p><p>请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3</p><p>（将请求打包一起发送，然后服务器一起打包回来响应）</p><p><strong>拓展知识：</strong></p><ul><li>管线化机制通过持久连接完成，仅 <code>HTTP / 1.1</code> 支持此技术（重点）</li><li>只有<code>get</code>和<code>head</code>请求可以进行管线化，而 <code>post</code> 有所限制（重点）</li><li>初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 <code>HTTP /1.1</code>版本的协议（重点）</li><li>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li><li><code>HTTP / 1.1</code>要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li><li>由于上面提到的服务器端的问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 <code>Chrome</code> 和 <code>Firefox</code> 默认并未开启管线化支持</li></ul><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><ul><li>创建对象有几种方法</li><li>原型、构造函数、实例、原型链</li><li>instanceof的原理</li><li>new运算符</li></ul><h3 id="创建对象有几种方法"><a href="#创建对象有几种方法" class="headerlink" title="创建对象有几种方法"></a>创建对象有几种方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>:<span class="string">'o1'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o11 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>:<span class="string">'o11'</span>&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.name=<span class="string">'o2'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> M();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> P = &#123;<span class="attr">name</span>:<span class="string">'o3'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(P);</span><br></pre></td></tr></table></figure><h3 id="原型、构造函数、实例、原型链"><a href="#原型、构造函数、实例、原型链" class="headerlink" title="原型、构造函数、实例、原型链"></a>原型、构造函数、实例、原型链</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404091811124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name=name&#125;;    <span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> M(<span class="string">'o2'</span>);   <span class="comment">//实例</span></span><br></pre></td></tr></table></figure><p>构造函数和原型对象的关系<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404092424139.png"  alt=""></p><p>实例和构造函数的关系</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404092715485.png"  alt=""></p><p>原型链：通过原型链的方式，找到原型对象，原型对象的方法是被不同实例所共有的。例如Object上有toString()方法，因此其它所有的实例都共有这个方法。</p><h3 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404093505976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br><code>instanceof</code>原理就是判断当前实例是不是当前构造函数的实例对象，判断依据就是实例对象的<code>__proto__</code>和构造函数的<code>prototype</code>是否指向相同的引用，只要在一条原型链上，<code>instanceof</code>就会返回<code>true</code>。</p><p>很抽象是吧，下面我们还是举上文的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name=name&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> M(<span class="string">'o2'</span>);</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404094108600.png"  alt=""></p><p>因此，<code>instanceof</code>判断不严谨，比如m继承了a、b、c，我怎么判断是继承了哪一个呢？用<code>instanceof</code>判断都返回<code>true</code>。</p><p>下面就来，介绍<code>constructor</code>判断方式</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404094632985.png"  alt=""></p><h3 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h3><ul><li><p>一个新对象被创建。它继承自<code>foo.prototype</code></p></li><li><p>构造函数foo被执行。执行的时候，相应的参数会被传入，同时上下文（this）会被指定为这个新实例。<code>new foo</code> 等同于 <code>new foo()</code>，只能用在不传递任何参数的情况</p></li><li><p>如果构造函数返回一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象</p></li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p><strong>类与实例</strong></p><ul><li>类的声明</li><li>生成实例</li></ul><p><strong>类与继承</strong></p><ul><li>如何实现继承</li><li>继承的几种方式</li></ul><h3 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">/* 类的声明 */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name=<span class="string">'aaa'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* ES6中的class的声明 */</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Animal2</span></span>&#123;</span><br><span class="line">            <span class="keyword">constructor</span>()&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = <span class="string">'bbb'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 实例化一个类 */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> Animal(),<span class="keyword">new</span> Animal2());</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><p><strong>效果</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404101354316.png"  alt=""></p><h3 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h3><p><strong>方法一：借助构造函数来实现继承</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 借助构造函数来实现继承 */</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">fruit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = <span class="string">'fruit'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">apple</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          fruit.call(<span class="keyword">this</span>);</span><br><span class="line">          <span class="keyword">this</span>.type=<span class="string">'apple'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> apple);</span><br></pre></td></tr></table></figure><p>上述这种方式，是通过改变<code>fruit</code>构造函数运行时this指向，指向了<code>apple</code>上，但是<code>fruit</code>原型链上的东西并没有被继承。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 借助构造函数来实现继承 */</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">fruit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = <span class="string">'fruit'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fruit.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'吃水果啦！'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">apple</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          fruit.call(<span class="keyword">this</span>);</span><br><span class="line">          <span class="keyword">this</span>.type=<span class="string">'apple'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> apple().eat());</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404105822522.png"  alt=""><br>因此，通过构造函数来实现的继承，只能继承父类构造函数的属性，如果原型<code>prototype</code>上面还有方法甚至原型链上的方法，不会继承。</p><p><strong>方法二：借助原型链实现继承</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 借助原型链实现继承 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'fruit'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apple</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type=<span class="string">'apple'</span>;</span><br><span class="line">&#125;</span><br><span class="line">apple.prototype = <span class="keyword">new</span> fruit();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> apple());</span><br></pre></td></tr></table></figure><p>掌握之前原型链相关的知识，下面的等式应该就比较容易理解了<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040411063490.png"  alt=""><br>但这种继承方式也是有缺点的，下文来探讨这个问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 借助原型链实现继承 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'fruit'</span>;</span><br><span class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apple</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type=<span class="string">'apple'</span>;</span><br><span class="line">&#125;</span><br><span class="line">apple.prototype = <span class="keyword">new</span> fruit();</span><br><span class="line"><span class="keyword">var</span> app1 = <span class="keyword">new</span> apple();</span><br><span class="line"><span class="keyword">var</span> app2 = <span class="keyword">new</span> apple();</span><br><span class="line">app1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(app1,app2);</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404110957499.png"  alt=""></p><p>从上述结果来看，当我们修改某一个对象时，该函数的所有新出的实例对象都会跟着改变，这就造成了<code>污染</code>问题，肯定不是我们面向对象思想所想要的。（因为它们引用的是同一个父类实例对象）</p><p><strong>方式三：组合方式实现继承</strong></p><p>这种方式就是结合前两种的优点，弥补它们的缺点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;面向对象&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="comment">/* 关于继承的几种方式</span></span><br><span class="line"><span class="comment">        **使用方法：</span></span><br><span class="line"><span class="comment">        **读者按需将对应模块注释取消掉即可 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 借助原型链实现继承 */</span></span><br><span class="line">        <span class="comment">/*function fruit()&#123;</span></span><br><span class="line"><span class="comment">            this.name = 'fruit';</span></span><br><span class="line"><span class="comment">            this.arr = [1,2,3];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        function apple()&#123;</span></span><br><span class="line"><span class="comment">            this.type='apple';</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        apple.prototype = new fruit();</span></span><br><span class="line"><span class="comment">        var app1 = new apple();</span></span><br><span class="line"><span class="comment">        var app2 = new apple();</span></span><br><span class="line"><span class="comment">        app1.arr.push(4);</span></span><br><span class="line"><span class="comment">        console.log(app1,app2);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 组合方式实现继承 */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *此方法的缺点：new fruit() 父类构造函数执行了两次，可以但没必要</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fruit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = <span class="string">'fruit'</span>;</span><br><span class="line">            <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">apple</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fruit.call(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">this</span>.type=<span class="string">'apple'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        apple.prototype = <span class="keyword">new</span> fruit();  <span class="comment">//这里拿的是父类的实例，没有自己的constructor</span></span><br><span class="line">        <span class="keyword">var</span> app1 = <span class="keyword">new</span> apple();</span><br><span class="line">        <span class="keyword">var</span> app2 = <span class="keyword">new</span> apple();</span><br><span class="line">        app1.arr.push(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//console.log(app1,app2);</span></span><br><span class="line">        <span class="comment">//console.log(app1.constructor,app2.constructor)   </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 组合方式实现继承优化1 */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fruit1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = <span class="string">'fruit'</span>;</span><br><span class="line">            <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">apple1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fruit.call(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">this</span>.type=<span class="string">'apple'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        apple1.prototype = fruit1.prototype;  <span class="comment">//这里拿的是父类的原型对象，但依旧没有自己的constructor</span></span><br><span class="line">        <span class="keyword">var</span> app3 = <span class="keyword">new</span> apple1();</span><br><span class="line">        <span class="keyword">var</span> app4 = <span class="keyword">new</span> apple1();</span><br><span class="line">        app3.arr.push(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//console.log(app3,app4);</span></span><br><span class="line">        <span class="comment">//判断实例</span></span><br><span class="line">        <span class="comment">//console.log(app3 instanceof apple1);</span></span><br><span class="line">        <span class="comment">//console.log(app3 instanceof fruit1); //这里无法判断当前对象是由父类产生的实例对象还是由子类产生的实例对象</span></span><br><span class="line">        <span class="comment">//判断构造函数</span></span><br><span class="line">        <span class="comment">//console.log(app3.constructor);      </span></span><br><span class="line">        <span class="comment">//console.log(app4.constructor);       //因为和父类的原型对象是一个对象，导致constructor也是指向的父类的constructor，无法判断自己</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 组合方式实现继承优化2 */</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fruit2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = <span class="string">'fruit'</span>;</span><br><span class="line">            <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">apple2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fruit.call(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">this</span>.type=<span class="string">'apple'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        apple2.prototype = <span class="built_in">Object</span>.create(fruit2.prototype);  <span class="comment">//这里使用Object.create()方法，和之前直接用fruit2.prototype来说，它创建了一个中间对象，和父类不是指向同一个区域了</span></span><br><span class="line">        <span class="comment">//这样就能区分父类和子类的原型对象了，达到父类和子类原型对象的隔离效果</span></span><br><span class="line">        apple2.prototype.constructor = apple2;  <span class="comment">//由于隔离了父类子类的原型对象，我们就可以指定子类自己的constructor</span></span><br><span class="line">        <span class="keyword">var</span> app5 = <span class="keyword">new</span> apple2();</span><br><span class="line">        <span class="keyword">var</span> app6 = <span class="keyword">new</span> apple2();</span><br><span class="line">        app5.arr.push(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(app5,app6);</span><br><span class="line">         <span class="comment">//判断实例</span></span><br><span class="line">        <span class="built_in">console</span>.log(app5 <span class="keyword">instanceof</span> apple2);</span><br><span class="line">        <span class="built_in">console</span>.log(app5 <span class="keyword">instanceof</span> fruit2); <span class="comment">//因此，这里可以判断当前对象是由父类产生的实例对象还是由子类产生的实例对象</span></span><br><span class="line">        <span class="comment">//判断构造函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(app5.constructor);       <span class="comment">//指向的是自己的constructor</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="通信类"><a href="#通信类" class="headerlink" title="通信类"></a>通信类</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><ul><li>什么是同源策略及限制</li><li>前后端如何通信</li><li>如何创建Ajax</li><li>跨域通信的几种方式（重点）</li></ul><h3 id="什么是同源策略及限制"><a href="#什么是同源策略及限制" class="headerlink" title="什么是同源策略及限制"></a>什么是同源策略及限制</h3><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。<br>这是一个用于隔离潜在恶意文件的关键的安全机制。</p><p> 源包括协议、域名、端口</p><ul><li>Cookie、LocalStorage和IndexDB无法读取</li><li>DOM无法获得</li><li>AJAX请求不能发送</li></ul><h3 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h3><ul><li>Ajax（同源下的通信）</li><li>WebSocket（不限制，不受同源策略的限制）</li><li>CORS（支持同源通信，也支持跨域通信，新型）</li></ul><h3 id="如何创建Ajax"><a href="#如何创建Ajax" class="headerlink" title="如何创建Ajax"></a>如何创建Ajax</h3><ul><li>XMLHttpRequest（高级浏览器才支持）对象的工作流程</li><li>兼容性处理</li><li>事件的触发条件</li><li>事件的触发顺序</li></ul><h3 id="跨域通信的几种方式（重点）"><a href="#跨域通信的几种方式（重点）" class="headerlink" title="跨域通信的几种方式（重点）"></a>跨域通信的几种方式（重点）</h3><ul><li>JSONP</li><li>Hash（改变页面不刷新，search改变会刷新，因此search不可以）</li><li>postMessage（H5中出现的标准，实现跨域通信）</li><li>WebSocket</li><li>CORS（可以理解为支持跨域通信的Ajax，在请求头上加了Origin）</li></ul><p><strong>JSONP实现原理：</strong></p><p>根据script标签异步加载而来</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404135628568.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040413390361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>将<code>html</code>加入<code>script</code>标签，即把请求发送出去<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404135715278.png"  alt=""></p><p>很关键一点是会向服务端发送一个<code>callbackName</code>，然后服务器就会响应如下内容（下面那个script里的内容）利用<code>callbackName</code>作为函数名来返回，而且本地必须有这个函数名的函数。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404133842188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br><strong>Hash与postMessage实现原理</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404135948962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br><strong>WebSocket实现原理</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040414064464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p><strong>CORS实现原理</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404141010376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>PS：CORS为什么支持跨域通信？</p><p>浏览器回拦截<code>Ajax</code>请求，如果觉得是跨域的，就会在请求头上加上<code>origin</code>。</p><h2 id="安全类"><a href="#安全类" class="headerlink" title="安全类"></a>安全类</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><ul><li><p>CSRF</p><p>  基本概念和缩写<br>  攻击原理<br>  防御措施</p></li><li><p>XSS</p></li></ul><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p><strong>基本概念和缩写</strong></p><p>CSRF，通常称为跨站请求伪造，英文名（Cross-site request forgery）缩写CSRF</p><p><strong>CSRF攻击原理</strong></p><ul><li>用户必须在网站登录过</li><li>网站中某个接口存在漏洞<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404141759423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></li></ul><p><strong>CSRF防御措施</strong></p><ul><li>Token验证</li><li>Referer验证（页面来源验证）</li><li>隐藏令牌（类似Token，隐藏在http的head头中，不放在链接上）</li></ul><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><strong>基本概念和缩写</strong></p><p>跨域脚本攻击（cross-site scripting）</p><p><strong>攻击原理</strong></p><p>比如可以在你的提交区里面写上script标签，即用一些渠道向你的页面注入js脚本</p><p><strong>防御措施</strong></p><p>让插入的js不可执行</p><h3 id="CSRF与XSS区别"><a href="#CSRF与XSS区别" class="headerlink" title="CSRF与XSS区别"></a>CSRF与XSS区别</h3><p>CSRF是利用本身的漏洞自动执行接口，依赖于用户登录网站</p><p>XSS是向页面注入js，js函数体里面做想做的事</p><h2 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><ul><li>排序</li><li>堆栈、队列、链表</li><li>递归</li><li>波兰式和逆波兰式</li><li>…</li></ul><p>PS：由于文章篇幅所限，并且算法这一块需要的是自己平时的积累，这里就不作长文加载了，关于算法这一块我会在github里有相应专栏，记录题库。因此，在这里就给大家分享一些比较好的文章提供学习。</p><hr/><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>快速排序：<a href="https://segmentfault.com/a/1190000009426421" target="_blank" rel="noopener">传送门</a></li><li>选择排序：<a href="https://segmentfault.com/a/1190000009366805" target="_blank" rel="noopener">传送门</a></li><li>希尔排序：<a href="https://segmentfault.com/a/1190000009461832" target="_blank" rel="noopener">传送门</a></li></ul><p><a href="https://chocolate.blog.csdn.net/article/details/105218288" target="_blank" rel="noopener">推荐：【再也不怕面试官要你手写排序算法】一文详细解读前后端之各种排序算法及知识拓展（附图示） JS / C / C++</a></p><h3 id="堆栈、队列、链表"><a href="#堆栈、队列、链表" class="headerlink" title="堆栈、队列、链表"></a>堆栈、队列、链表</h3><p><a href="https://juejin.im/entry/58759e79128fe1006b48cdfd" target="_blank" rel="noopener">参考：JS中的数据结构与算法</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><a href="https://segmentfault.com/a/1190000009857470" target="_blank" rel="noopener">参考：JS中的递归</a></p><h3 id="波兰式和逆波兰式"><a href="#波兰式和逆波兰式" class="headerlink" title="波兰式和逆波兰式"></a>波兰式和逆波兰式</h3><p><a href="https://www.cnblogs.com/chenying99/p/3675876.html" target="_blank" rel="noopener">参考：波兰式、逆波兰式与表达式求值</a></p><p><a href="https://github.com/Tairraos/rpn.js" target="_blank" rel="noopener">参考：源码</a></p><h3 id="关于算法的心得"><a href="#关于算法的心得" class="headerlink" title="关于算法的心得"></a>关于算法的心得</h3><p>首先，对于前端来说，算法要求没有后端那么严格，考察的一般不会很刁专，一般就是看下你的思考能力。如果一开始就考察算法题，如果你回答不了的话，也很正常，或许这不是一个关于前端的部门…可能招的是算法工程师，算法这一块问的话，多半是中间时间段。算法这一块的话，在于平时积累，如果时间充裕的话，可以深入了解一点，这也是面试加分点，如果时间紧迫的话，把上文提到的部分专题弄懂已经不错了。</p><hr/><h2 id="二面-三面"><a href="#二面-三面" class="headerlink" title="二面 / 三面"></a>二面 / 三面</h2><h3 id="面试技巧-1"><a href="#面试技巧-1" class="headerlink" title="面试技巧"></a>面试技巧</h3><ul><li>知识面要广</li><li>理解要深刻</li><li>内心要诚实</li><li>态度要谦虚</li><li>回答要灵活</li><li>要学会赞美</li></ul><h2 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><ul><li>什么是DOCTYPE及作用</li><li>浏览器渲染过程</li><li>重排Reflow</li><li>重绘Repaint</li><li>布局Layout</li></ul><h3 id="什么是DOCTYPE及作用"><a href="#什么是DOCTYPE及作用" class="headerlink" title="什么是DOCTYPE及作用"></a>什么是DOCTYPE及作用</h3><ul><li>DTD（document type ，文档类型定义）是一系列的语法规则，用来定义XML或（X）HTML的文件类型。浏览器会使用它来判断文件类型，决定使用何种协议来解析，以及切换浏览器模式</li><li>DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器就会出现一些解析错误。（简单来说，就是告诉浏览器我用了哪一个DTD）</li></ul><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404161808788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br>PS：这里要记住html5该如何声明，以及4.0版本有严格模式和传统模式，具体区别如上图下划线所示</p><h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404162046639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><p><strong>简单快速回答：</strong></p><p>第一步，HTML经过HTML解析器解析成为DOM Tree</p><p>第二步，CSS通过CSS解析器形成样式规则</p><p>第三步，将两个DOM结合形成Render Tree，这里就类似于告诉浏览器渲染树结构基本出来了，此时有一个平行操作，Layout，经过这个，就能知道元素具体应该显示在屏幕在哪个位置（宽、高、颜色等）</p><p>最后一步，浏览器通过GUI画图，呈现页面内容，最后Display显示页面</p><hr/><p>下面通过几个比较好理解的图形来将抽象具体化：</p><p><strong>DOM Tree</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404163122362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br><strong>CSSOM Tree</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404163149664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br><strong>Render Tree</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404163230751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br><strong>Layout</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404163324722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h3 id="重排Reflow"><a href="#重排Reflow" class="headerlink" title="重排Reflow"></a>重排Reflow</h3><p><strong>定义</strong></p><p>DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow</p><p><strong>触发Reflow</strong></p><ul><li>当你增加、删除、修改<code>DOM</code>结点时，会导致 <code>Reflow</code> 或 <code>Repaint</code></li><li>当你移动<code>DOM</code>的位置，或是搞个动画的时候</li><li>当你修改<code>CSS</code>样式的时候</li><li>当你 <code>Resize</code> 窗口的时候（移动端没有这个问题），或是滚动的时候</li><li>当你修改网页的默认字体时候（影响比较大，性能问题）</li></ul><h3 id="重绘Repaint"><a href="#重绘Repaint" class="headerlink" title="重绘Repaint"></a>重绘Repaint</h3><p><strong>定义</strong></p><p>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为<code>repaint</code>。即页面需要呈现的内容，一起画到屏幕上。</p><p><strong>触发Repaint</strong></p><ul><li>DOM改动</li><li>CSS改动</li></ul><p><strong>（重点）如何尽量减小Repaint？</strong></p><p>比如页面有一个计算器，用户在输入框输入一些计算表达式，最后显示计算结果，然后把输入给隐藏掉。这里就有两个交互，先是用户输入，将输入隐藏掉，然后将结果显示出来。这两个交互呈现内容不一样，当然就需要Repaint，那怎么做少画点东西？</p><p>好像是有一个documentFrame这个东西，把n个节点创建成一个片段，向浏览器一次添加这个片段。</p><p>（这里我的朋友考察过，遗留一下这个问题，可以帮助我完善这个问题，谢谢！）</p><h2 id="js运行机制"><a href="#js运行机制" class="headerlink" title="js运行机制"></a>js运行机制</h2><p>关于这一专题，我之前的文章也是写的挺多的了。</p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104907304" target="_blank" rel="noopener">推荐阅读：【金三银四】一个问题就知道你会不会JS了 阿里、头条真题解析</a></p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104990407" target="_blank" rel="noopener">推荐阅读：【金三银四】 一文弄懂 js 数据类型、堆栈内存、作用域（链）、闭包知识拓展 （一）</a></p><p>下面就例举几个经典题，读者可以好好体会一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;js运行机制&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">        &#125;,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">   &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><ul><li>如何理解JS的单线程</li><li>什么是任务队列</li><li>什么是Event Loop</li></ul><p>以上三个问题的详细表述：</p><p><a href="https://blog.csdn.net/weixin_42429718/article/details/104990407" target="_blank" rel="noopener">推荐阅读：【金三银四】 一文弄懂 js 数据类型、堆栈内存、作用域（链）、闭包知识拓展 （一）</a></p><h3 id="如何理解JS的单线程"><a href="#如何理解JS的单线程" class="headerlink" title="如何理解JS的单线程"></a>如何理解JS的单线程</h3><p>学过JS，不对，听过JS的同学应该都知道，JS是单线程的，而浏览器是多线程的，分配的时间内js只能干一件事情</p><h3 id="什么是任务队列"><a href="#什么是任务队列" class="headerlink" title="什么是任务队列"></a>什么是任务队列</h3><p>分同步任务和异步任务</p><h3 id="什么是Event-Loop"><a href="#什么是Event-Loop" class="headerlink" title="什么是Event Loop"></a>什么是Event Loop</h3><p>为了解决同步和异步问题，浏览器提供了一个事件队列 Event Queue，根据特征不同，分为微任务和宏任务队列</p><p>执行顺序是：主线程代码 &gt; 微任务 &gt; 宏任务</p><p><strong>宏任务：</strong></p><p>定时器例如setTimeout（异步）、事件绑定</p><p><strong>微任务：</strong></p><p>await（异步，执行x函数并等待返回结果，有结果再执行下面代码）</p><p>resolve() / reject() 执行的时候把 then / catch 中的代码执行</p><p>promise、async</p><p><strong>特殊情况：</strong></p><p>new Promise（同步）会立即执行</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>理解Js的单线程的概念</li><li>理解任务队列</li><li>理解 Event Loop</li><li>理解哪些语句会放入异步任务队列</li><li>理解语句放入异步任务队列的时机</li></ul><h2 id="页面性能"><a href="#页面性能" class="headerlink" title="页面性能"></a>页面性能</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><p>提升页面性能的方法有哪些？</p><ul><li>1、资源压缩合并，减少HTTP请求</li><li>2、非核心代码异步加载——异步加载的方式——异步加载的区别</li><li>3、利用浏览器缓存——缓存的分类——缓存的原理</li><li>4、使用CDN</li><li>5、预解析DNS</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"x-dns-prefetch-control"</span> content=<span class="string">"on"</span>&gt; <span class="comment">//打开a标签dns预解析</span></span><br><span class="line"><span class="comment">//有些https默认关了dns预解析，使用上述可以打开（加分点）</span></span><br><span class="line">&lt;link rel=<span class="string">"dns-prefetch"</span> href=<span class="string">"//host_name_to_prefetch.com"</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>1、异步加载的方式</p><ul><li>动态脚本加载（用过js添加到document中，比如加入到body或head中）</li><li>defer</li><li>async</li></ul><p>2、异步加载的区别</p><p>（1）<code>defer</code>是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行<br>（2）<code>async</code>是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p><strong>1、缓存的分类</strong></p><ul><li><p>① <strong>强缓存</strong>（不用任何请求，拿过来就用，如果两个都下发，以第二个<code>Cache</code>为准）</p><p>  <strong>Expires（过期时间-服务器绝对时间）</strong> Expires:Thu,21 Jan 2017 23:39:02 GMT<br>  （会导致客户端时间和服务器时间之间时间差问题）<br>  <strong>Cache-Control（客户端相对时间，单位秒）</strong> Cache-Control:max-age=3600</p></li></ul><ul><li><p>② <strong>协商缓存</strong>（浏览器发现本地有这个副本，但是不确定用不用它，于是得向服务器问一下，这个副本要不要用）</p><p>  <strong>Last-Modified</strong>（拿到某个资源文件时，通过这个字段服务器下发一个时间）  <strong>If-Modified-Since</strong> （当下次请求这个资源是否发生变化时，是用这个<code>key</code>值，对比两个时间）</p><p>  Last-Modified: Web,26 Jan 2017 00:35:11 GMT</p><p>  （上述方式会存在问题，例如我可能时间上修改了，但是内容并没有修改）</p><p>  <strong>Etage</strong>（解决上述问题，服务器给Etage值，当过了强缓存时间，浏览器请求是否可用副本时，会在http请求头中用 <strong>If-None-Match</strong> 当做key值，加上<code>value</code>，此value就是Etage的值）</p></li></ul><p><strong>PS：（面试真题-鹅厂）你知道浏览器与缓存相关的http头有哪些？</strong></p><p>答案就是上述<strong>加粗字体</strong></p><h2 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h2><p><strong>问法：如何检测JS错误，如何保证你的产品质量？</strong></p><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><ul><li>前端错误的分类</li><li>错误的捕获方式</li><li>上报错误的基本原理</li></ul><h3 id="前端错误的分类"><a href="#前端错误的分类" class="headerlink" title="前端错误的分类"></a>前端错误的分类</h3><p>即时运行错误：代码错误<br>资源加载错误</p><h3 id="错误的捕获方式"><a href="#错误的捕获方式" class="headerlink" title="错误的捕获方式"></a>错误的捕获方式</h3><p><strong>即时运行错误</strong>的捕获方式</p><p>（1） try…catch<br>（2）window.onerror（无法捕获资源加载错误，理由如下）</p><p><strong>资源加载错误</strong>（上述原因：因为资源加载错误不会冒泡）</p><p>（1）<code>object.onerror</code>（节点上绑定<code>onerror</code>事件）</p><p>（2）<code>performance.getEntries()</code> （获得目前已加载的资源，例如图片，然后用document.getElementsByTagName(‘img’)来获取需要加载的图片，然后用总的去减已加载的，就能知道未加载的有多少了）</p><p>（3）<code>Error</code>事件捕获（之前说不能冒泡，但可以捕获）</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404205139389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404205209691.png"  alt=""></p><p><strong>延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？</strong></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040420481855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""><br><strong>处理</strong></p><ul><li>在script标签增加 <code>crossorigin</code> 属性</li><li>设置js资源响应头 `Access-Control-Allow-Origin:*（可以指定域名）</li></ul><h3 id="上报错误的基本原理"><a href="#上报错误的基本原理" class="headerlink" title="上报错误的基本原理"></a>上报错误的基本原理</h3><p>1、采用Ajax通信的方式上报<br>2、利用Image对象上报（重点，加分点）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;利用Image对象上报&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        (<span class="keyword">new</span> Image()).src=<span class="string">'http://baidu.com/test?name=123'</span>;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>此时，我们查看<code>Nerwork</code>，可以发现，我们的请求已经发出去了（比Ajax简单，不用借用任何第三方库）<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200404205701538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyOTcxOA==,size_16,color_FFFFFF,t_70"  alt=""></p><h2 id="三面-四面"><a href="#三面-四面" class="headerlink" title="三面 / 四面"></a>三面 / 四面</h2><h3 id="面试技巧-2"><a href="#面试技巧-2" class="headerlink" title="面试技巧"></a>面试技巧</h3><ul><li>准备要充分</li><li>描述要熟练</li><li>引导找时机</li><li>优势要发挥</li><li>回答要灵活</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p><font color="Tomato"><strong>如若本文有瑕疵需修改的地方，请提出来，谢谢您的贡献！</strong></font></p><p><font color=chocolate>欢迎关注微信公众号：小狮子前端Vue</font></p><p>谢谢您的支持！✿✿ヽ(°▽°)ノ✿</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">学如逆水行舟，不进则退</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
